/*! For license information please see 53.88328536.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkreact_shopping_cart=self.webpackChunkreact_shopping_cart||[]).push([[53],{"./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}__webpack_require__.d(__webpack_exports__,{Z:function(){return _arrayLikeToArray}})},"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}__webpack_require__.d(__webpack_exports__,{Z:function(){return _asyncToGenerator}})},"./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Z:function(){return _regeneratorRuntime}});var _typeof_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/typeof.js");function _regeneratorRuntime(){_regeneratorRuntime=function _regeneratorRuntime(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,defineProperty=Object.defineProperty||function(obj,key,desc){obj[key]=desc.value},$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function define(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return defineProperty(generator,"_invoke",{value:makeInvokeMethod(innerFn,self,context)}),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==(0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__.Z)(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;defineProperty(this,"_invoke",{value:function value(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}function maybeInvokeDelegate(delegate,context){var methodName=context.method,method=delegate.iterator[methodName];if(void 0===method)return context.delegate=null,"throw"===methodName&&delegate.iterator.return&&(context.method="return",context.arg=void 0,maybeInvokeDelegate(delegate,context),"throw"===context.method)||"return"!==methodName&&(context.method="throw",context.arg=new TypeError("The iterator does not provide a '"+methodName+"' method")),ContinueSentinel;var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=void 0),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,defineProperty(Gp,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),defineProperty(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(val){var object=Object(val),keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function reset(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=void 0)},stop:function stop(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function dispatchException(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=void 0),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function abrupt(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function complete(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function finish(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function _catch(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function delegateYield(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=void 0),ContinueSentinel}},exports}},"./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Z:function(){return _slicedToArray}});var unsupportedIterableToArray=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");function _slicedToArray(arr,i){return function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}(arr)||function _iterableToArrayLimit(arr,i){var _i=null==arr?null:"undefined"!=typeof Symbol&&arr[Symbol.iterator]||arr["@@iterator"];if(null!=_i){var _s,_e,_x,_r,_arr=[],_n=!0,_d=!1;try{if(_x=(_i=_i.call(arr)).next,0===i){if(Object(_i)!==_i)return;_n=!1}else for(;!(_n=(_s=_x.call(_i)).done)&&(_arr.push(_s.value),_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&null!=_i.return&&(_r=_i.return(),Object(_r)!==_r))return}finally{if(_d)throw _e}}return _arr}}(arr,i)||(0,unsupportedIterableToArray.Z)(arr,i)||function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},"./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Z:function(){return _toConsumableArray}});var arrayLikeToArray=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");var unsupportedIterableToArray=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");function _toConsumableArray(arr){return function _arrayWithoutHoles(arr){if(Array.isArray(arr))return(0,arrayLikeToArray.Z)(arr)}(arr)||function _iterableToArray(iter){if("undefined"!=typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}(arr)||(0,unsupportedIterableToArray.Z)(arr)||function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},"./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{Z:function(){return _unsupportedIterableToArray}});var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return(0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.Z)(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?(0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.Z)(o,minLen):void 0}}},"./node_modules/axios/lib/axios.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){function bind(fn,thisArg){return function wrap(){return fn.apply(thisArg,arguments)}}__webpack_require__.d(__webpack_exports__,{Z:function(){return lib_axios}});const{toString:utils_toString}=Object.prototype,{getPrototypeOf:getPrototypeOf}=Object,kindOf=(cache=Object.create(null),thing=>{const str=utils_toString.call(thing);return cache[str]||(cache[str]=str.slice(8,-1).toLowerCase())});var cache;const kindOfTest=type=>(type=type.toLowerCase(),thing=>kindOf(thing)===type),typeOfTest=type=>thing=>typeof thing===type,{isArray:isArray}=Array,isUndefined=typeOfTest("undefined");const isArrayBuffer=kindOfTest("ArrayBuffer");const isString=typeOfTest("string"),isFunction=typeOfTest("function"),isNumber=typeOfTest("number"),isObject=thing=>null!==thing&&"object"==typeof thing,isPlainObject=val=>{if("object"!==kindOf(val))return!1;const prototype=getPrototypeOf(val);return!(null!==prototype&&prototype!==Object.prototype&&null!==Object.getPrototypeOf(prototype)||Symbol.toStringTag in val||Symbol.iterator in val)},isDate=kindOfTest("Date"),isFile=kindOfTest("File"),isBlob=kindOfTest("Blob"),isFileList=kindOfTest("FileList"),isURLSearchParams=kindOfTest("URLSearchParams");function forEach(obj,fn,{allOwnKeys:allOwnKeys=!1}={}){if(null==obj)return;let i,l;if("object"!=typeof obj&&(obj=[obj]),isArray(obj))for(i=0,l=obj.length;i<l;i++)fn.call(null,obj[i],i,obj);else{const keys=allOwnKeys?Object.getOwnPropertyNames(obj):Object.keys(obj),len=keys.length;let key;for(i=0;i<len;i++)key=keys[i],fn.call(null,obj[key],key,obj)}}function findKey(obj,key){key=key.toLowerCase();const keys=Object.keys(obj);let _key,i=keys.length;for(;i-- >0;)if(_key=keys[i],key===_key.toLowerCase())return _key;return null}const _global="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:__webpack_require__.g,isContextDefined=context=>!isUndefined(context)&&context!==_global;const isTypedArray=(TypedArray="undefined"!=typeof Uint8Array&&getPrototypeOf(Uint8Array),thing=>TypedArray&&thing instanceof TypedArray);var TypedArray;const isHTMLForm=kindOfTest("HTMLFormElement"),utils_hasOwnProperty=(({hasOwnProperty:hasOwnProperty})=>(obj,prop)=>hasOwnProperty.call(obj,prop))(Object.prototype),isRegExp=kindOfTest("RegExp"),reduceDescriptors=(obj,reducer)=>{const descriptors=Object.getOwnPropertyDescriptors(obj),reducedDescriptors={};forEach(descriptors,((descriptor,name)=>{!1!==reducer(descriptor,name,obj)&&(reducedDescriptors[name]=descriptor)})),Object.defineProperties(obj,reducedDescriptors)},ALPHA="abcdefghijklmnopqrstuvwxyz",ALPHABET={DIGIT:"0123456789",ALPHA:ALPHA,ALPHA_DIGIT:ALPHA+ALPHA.toUpperCase()+"0123456789"};const isAsyncFn=kindOfTest("AsyncFunction");var utils={isArray:isArray,isArrayBuffer:isArrayBuffer,isBuffer:function isBuffer(val){return null!==val&&!isUndefined(val)&&null!==val.constructor&&!isUndefined(val.constructor)&&isFunction(val.constructor.isBuffer)&&val.constructor.isBuffer(val)},isFormData:thing=>{let kind;return thing&&("function"==typeof FormData&&thing instanceof FormData||isFunction(thing.append)&&("formdata"===(kind=kindOf(thing))||"object"===kind&&isFunction(thing.toString)&&"[object FormData]"===thing.toString()))},isArrayBufferView:function isArrayBufferView(val){let result;return result="undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(val):val&&val.buffer&&isArrayBuffer(val.buffer),result},isString:isString,isNumber:isNumber,isBoolean:thing=>!0===thing||!1===thing,isObject:isObject,isPlainObject:isPlainObject,isUndefined:isUndefined,isDate:isDate,isFile:isFile,isBlob:isBlob,isRegExp:isRegExp,isFunction:isFunction,isStream:val=>isObject(val)&&isFunction(val.pipe),isURLSearchParams:isURLSearchParams,isTypedArray:isTypedArray,isFileList:isFileList,forEach:forEach,merge:function merge(){const{caseless:caseless}=isContextDefined(this)&&this||{},result={},assignValue=(val,key)=>{const targetKey=caseless&&findKey(result,key)||key;isPlainObject(result[targetKey])&&isPlainObject(val)?result[targetKey]=merge(result[targetKey],val):isPlainObject(val)?result[targetKey]=merge({},val):isArray(val)?result[targetKey]=val.slice():result[targetKey]=val};for(let i=0,l=arguments.length;i<l;i++)arguments[i]&&forEach(arguments[i],assignValue);return result},extend:(a,b,thisArg,{allOwnKeys:allOwnKeys}={})=>(forEach(b,((val,key)=>{thisArg&&isFunction(val)?a[key]=bind(val,thisArg):a[key]=val}),{allOwnKeys:allOwnKeys}),a),trim:str=>str.trim?str.trim():str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,""),stripBOM:content=>(65279===content.charCodeAt(0)&&(content=content.slice(1)),content),inherits:(constructor,superConstructor,props,descriptors)=>{constructor.prototype=Object.create(superConstructor.prototype,descriptors),constructor.prototype.constructor=constructor,Object.defineProperty(constructor,"super",{value:superConstructor.prototype}),props&&Object.assign(constructor.prototype,props)},toFlatObject:(sourceObj,destObj,filter,propFilter)=>{let props,i,prop;const merged={};if(destObj=destObj||{},null==sourceObj)return destObj;do{for(props=Object.getOwnPropertyNames(sourceObj),i=props.length;i-- >0;)prop=props[i],propFilter&&!propFilter(prop,sourceObj,destObj)||merged[prop]||(destObj[prop]=sourceObj[prop],merged[prop]=!0);sourceObj=!1!==filter&&getPrototypeOf(sourceObj)}while(sourceObj&&(!filter||filter(sourceObj,destObj))&&sourceObj!==Object.prototype);return destObj},kindOf:kindOf,kindOfTest:kindOfTest,endsWith:(str,searchString,position)=>{str=String(str),(void 0===position||position>str.length)&&(position=str.length),position-=searchString.length;const lastIndex=str.indexOf(searchString,position);return-1!==lastIndex&&lastIndex===position},toArray:thing=>{if(!thing)return null;if(isArray(thing))return thing;let i=thing.length;if(!isNumber(i))return null;const arr=new Array(i);for(;i-- >0;)arr[i]=thing[i];return arr},forEachEntry:(obj,fn)=>{const iterator=(obj&&obj[Symbol.iterator]).call(obj);let result;for(;(result=iterator.next())&&!result.done;){const pair=result.value;fn.call(obj,pair[0],pair[1])}},matchAll:(regExp,str)=>{let matches;const arr=[];for(;null!==(matches=regExp.exec(str));)arr.push(matches);return arr},isHTMLForm:isHTMLForm,hasOwnProperty:utils_hasOwnProperty,hasOwnProp:utils_hasOwnProperty,reduceDescriptors:reduceDescriptors,freezeMethods:obj=>{reduceDescriptors(obj,((descriptor,name)=>{if(isFunction(obj)&&-1!==["arguments","caller","callee"].indexOf(name))return!1;const value=obj[name];isFunction(value)&&(descriptor.enumerable=!1,"writable"in descriptor?descriptor.writable=!1:descriptor.set||(descriptor.set=()=>{throw Error("Can not rewrite read-only method '"+name+"'")}))}))},toObjectSet:(arrayOrString,delimiter)=>{const obj={},define=arr=>{arr.forEach((value=>{obj[value]=!0}))};return isArray(arrayOrString)?define(arrayOrString):define(String(arrayOrString).split(delimiter)),obj},toCamelCase:str=>str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function replacer(m,p1,p2){return p1.toUpperCase()+p2})),noop:()=>{},toFiniteNumber:(value,defaultValue)=>(value=+value,Number.isFinite(value)?value:defaultValue),findKey:findKey,global:_global,isContextDefined:isContextDefined,ALPHABET:ALPHABET,generateString:(size=16,alphabet=ALPHABET.ALPHA_DIGIT)=>{let str="";const{length:length}=alphabet;for(;size--;)str+=alphabet[Math.random()*length|0];return str},isSpecCompliantForm:function isSpecCompliantForm(thing){return!!(thing&&isFunction(thing.append)&&"FormData"===thing[Symbol.toStringTag]&&thing[Symbol.iterator])},toJSONObject:obj=>{const stack=new Array(10),visit=(source,i)=>{if(isObject(source)){if(stack.indexOf(source)>=0)return;if(!("toJSON"in source)){stack[i]=source;const target=isArray(source)?[]:{};return forEach(source,((value,key)=>{const reducedValue=visit(value,i+1);!isUndefined(reducedValue)&&(target[key]=reducedValue)})),stack[i]=void 0,target}}return source};return visit(obj,0)},isAsyncFn:isAsyncFn,isThenable:thing=>thing&&(isObject(thing)||isFunction(thing))&&isFunction(thing.then)&&isFunction(thing.catch)};function AxiosError(message,code,config,request,response){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=message,this.name="AxiosError",code&&(this.code=code),config&&(this.config=config),request&&(this.request=request),response&&(this.response=response)}utils.inherits(AxiosError,Error,{toJSON:function toJSON(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:utils.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});const AxiosError_prototype=AxiosError.prototype,descriptors={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((code=>{descriptors[code]={value:code}})),Object.defineProperties(AxiosError,descriptors),Object.defineProperty(AxiosError_prototype,"isAxiosError",{value:!0}),AxiosError.from=(error,code,config,request,response,customProps)=>{const axiosError=Object.create(AxiosError_prototype);return utils.toFlatObject(error,axiosError,(function filter(obj){return obj!==Error.prototype}),(prop=>"isAxiosError"!==prop)),AxiosError.call(axiosError,error.message,code,config,request,response),axiosError.cause=error,axiosError.name=error.name,customProps&&Object.assign(axiosError,customProps),axiosError};var core_AxiosError=AxiosError;function isVisitable(thing){return utils.isPlainObject(thing)||utils.isArray(thing)}function removeBrackets(key){return utils.endsWith(key,"[]")?key.slice(0,-2):key}function renderKey(path,key,dots){return path?path.concat(key).map((function each(token,i){return token=removeBrackets(token),!dots&&i?"["+token+"]":token})).join(dots?".":""):key}const predicates=utils.toFlatObject(utils,{},null,(function filter(prop){return/^is[A-Z]/.test(prop)}));var helpers_toFormData=function toFormData(obj,formData,options){if(!utils.isObject(obj))throw new TypeError("target must be an object");formData=formData||new FormData;const metaTokens=(options=utils.toFlatObject(options,{metaTokens:!0,dots:!1,indexes:!1},!1,(function defined(option,source){return!utils.isUndefined(source[option])}))).metaTokens,visitor=options.visitor||defaultVisitor,dots=options.dots,indexes=options.indexes,useBlob=(options.Blob||"undefined"!=typeof Blob&&Blob)&&utils.isSpecCompliantForm(formData);if(!utils.isFunction(visitor))throw new TypeError("visitor must be a function");function convertValue(value){if(null===value)return"";if(utils.isDate(value))return value.toISOString();if(!useBlob&&utils.isBlob(value))throw new core_AxiosError("Blob is not supported. Use a Buffer instead.");return utils.isArrayBuffer(value)||utils.isTypedArray(value)?useBlob&&"function"==typeof Blob?new Blob([value]):Buffer.from(value):value}function defaultVisitor(value,key,path){let arr=value;if(value&&!path&&"object"==typeof value)if(utils.endsWith(key,"{}"))key=metaTokens?key:key.slice(0,-2),value=JSON.stringify(value);else if(utils.isArray(value)&&function isFlatArray(arr){return utils.isArray(arr)&&!arr.some(isVisitable)}(value)||(utils.isFileList(value)||utils.endsWith(key,"[]"))&&(arr=utils.toArray(value)))return key=removeBrackets(key),arr.forEach((function each(el,index){!utils.isUndefined(el)&&null!==el&&formData.append(!0===indexes?renderKey([key],index,dots):null===indexes?key:key+"[]",convertValue(el))})),!1;return!!isVisitable(value)||(formData.append(renderKey(path,key,dots),convertValue(value)),!1)}const stack=[],exposedHelpers=Object.assign(predicates,{defaultVisitor:defaultVisitor,convertValue:convertValue,isVisitable:isVisitable});if(!utils.isObject(obj))throw new TypeError("data must be an object");return function build(value,path){if(!utils.isUndefined(value)){if(-1!==stack.indexOf(value))throw Error("Circular reference detected in "+path.join("."));stack.push(value),utils.forEach(value,(function each(el,key){!0===(!(utils.isUndefined(el)||null===el)&&visitor.call(formData,el,utils.isString(key)?key.trim():key,path,exposedHelpers))&&build(el,path?path.concat(key):[key])})),stack.pop()}}(obj),formData};function encode(str){const charMap={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g,(function replacer(match){return charMap[match]}))}function AxiosURLSearchParams(params,options){this._pairs=[],params&&helpers_toFormData(params,this,options)}const AxiosURLSearchParams_prototype=AxiosURLSearchParams.prototype;AxiosURLSearchParams_prototype.append=function append(name,value){this._pairs.push([name,value])},AxiosURLSearchParams_prototype.toString=function toString(encoder){const _encode=encoder?function(value){return encoder.call(this,value,encode)}:encode;return this._pairs.map((function each(pair){return _encode(pair[0])+"="+_encode(pair[1])}),"").join("&")};var helpers_AxiosURLSearchParams=AxiosURLSearchParams;function buildURL_encode(val){return encodeURIComponent(val).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function buildURL(url,params,options){if(!params)return url;const _encode=options&&options.encode||buildURL_encode,serializeFn=options&&options.serialize;let serializedParams;if(serializedParams=serializeFn?serializeFn(params,options):utils.isURLSearchParams(params)?params.toString():new helpers_AxiosURLSearchParams(params,options).toString(_encode),serializedParams){const hashmarkIndex=url.indexOf("#");-1!==hashmarkIndex&&(url=url.slice(0,hashmarkIndex)),url+=(-1===url.indexOf("?")?"?":"&")+serializedParams}return url}var core_InterceptorManager=class InterceptorManager{constructor(){this.handlers=[]}use(fulfilled,rejected,options){return this.handlers.push({fulfilled:fulfilled,rejected:rejected,synchronous:!!options&&options.synchronous,runWhen:options?options.runWhen:null}),this.handlers.length-1}eject(id){this.handlers[id]&&(this.handlers[id]=null)}clear(){this.handlers&&(this.handlers=[])}forEach(fn){utils.forEach(this.handlers,(function forEachHandler(h){null!==h&&fn(h)}))}},defaults_transitional={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1};var browser={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:helpers_AxiosURLSearchParams,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},isStandardBrowserEnv:(()=>{let product;return("undefined"==typeof navigator||"ReactNative"!==(product=navigator.product)&&"NativeScript"!==product&&"NS"!==product)&&("undefined"!=typeof window&&"undefined"!=typeof document)})(),isStandardBrowserWebWorkerEnv:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,protocols:["http","https","file","blob","url","data"]};var helpers_formDataToJSON=function formDataToJSON(formData){function buildPath(path,value,target,index){let name=path[index++];const isNumericKey=Number.isFinite(+name),isLast=index>=path.length;if(name=!name&&utils.isArray(target)?target.length:name,isLast)return utils.hasOwnProp(target,name)?target[name]=[target[name],value]:target[name]=value,!isNumericKey;target[name]&&utils.isObject(target[name])||(target[name]=[]);return buildPath(path,value,target[name],index)&&utils.isArray(target[name])&&(target[name]=function arrayToObject(arr){const obj={},keys=Object.keys(arr);let i;const len=keys.length;let key;for(i=0;i<len;i++)key=keys[i],obj[key]=arr[key];return obj}(target[name])),!isNumericKey}if(utils.isFormData(formData)&&utils.isFunction(formData.entries)){const obj={};return utils.forEachEntry(formData,((name,value)=>{buildPath(function parsePropPath(name){return utils.matchAll(/\w+|\[(\w*)]/g,name).map((match=>"[]"===match[0]?"":match[1]||match[0]))}(name),value,obj,0)})),obj}return null};const DEFAULT_CONTENT_TYPE={"Content-Type":void 0};const defaults={transitional:defaults_transitional,adapter:["xhr","http"],transformRequest:[function transformRequest(data,headers){const contentType=headers.getContentType()||"",hasJSONContentType=contentType.indexOf("application/json")>-1,isObjectPayload=utils.isObject(data);isObjectPayload&&utils.isHTMLForm(data)&&(data=new FormData(data));if(utils.isFormData(data))return hasJSONContentType&&hasJSONContentType?JSON.stringify(helpers_formDataToJSON(data)):data;if(utils.isArrayBuffer(data)||utils.isBuffer(data)||utils.isStream(data)||utils.isFile(data)||utils.isBlob(data))return data;if(utils.isArrayBufferView(data))return data.buffer;if(utils.isURLSearchParams(data))return headers.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),data.toString();let isFileList;if(isObjectPayload){if(contentType.indexOf("application/x-www-form-urlencoded")>-1)return function toURLEncodedForm(data,options){return helpers_toFormData(data,new browser.classes.URLSearchParams,Object.assign({visitor:function(value,key,path,helpers){return browser.isNode&&utils.isBuffer(value)?(this.append(key,value.toString("base64")),!1):helpers.defaultVisitor.apply(this,arguments)}},options))}(data,this.formSerializer).toString();if((isFileList=utils.isFileList(data))||contentType.indexOf("multipart/form-data")>-1){const _FormData=this.env&&this.env.FormData;return helpers_toFormData(isFileList?{"files[]":data}:data,_FormData&&new _FormData,this.formSerializer)}}return isObjectPayload||hasJSONContentType?(headers.setContentType("application/json",!1),function stringifySafely(rawValue,parser,encoder){if(utils.isString(rawValue))try{return(parser||JSON.parse)(rawValue),utils.trim(rawValue)}catch(e){if("SyntaxError"!==e.name)throw e}return(encoder||JSON.stringify)(rawValue)}(data)):data}],transformResponse:[function transformResponse(data){const transitional=this.transitional||defaults.transitional,forcedJSONParsing=transitional&&transitional.forcedJSONParsing,JSONRequested="json"===this.responseType;if(data&&utils.isString(data)&&(forcedJSONParsing&&!this.responseType||JSONRequested)){const strictJSONParsing=!(transitional&&transitional.silentJSONParsing)&&JSONRequested;try{return JSON.parse(data)}catch(e){if(strictJSONParsing){if("SyntaxError"===e.name)throw core_AxiosError.from(e,core_AxiosError.ERR_BAD_RESPONSE,this,null,this.response);throw e}}}return data}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:browser.classes.FormData,Blob:browser.classes.Blob},validateStatus:function validateStatus(status){return status>=200&&status<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};utils.forEach(["delete","get","head"],(function forEachMethodNoData(method){defaults.headers[method]={}})),utils.forEach(["post","put","patch"],(function forEachMethodWithData(method){defaults.headers[method]=utils.merge(DEFAULT_CONTENT_TYPE)}));var lib_defaults=defaults;const ignoreDuplicateOf=utils.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]);const $internals=Symbol("internals");function normalizeHeader(header){return header&&String(header).trim().toLowerCase()}function normalizeValue(value){return!1===value||null==value?value:utils.isArray(value)?value.map(normalizeValue):String(value)}function matchHeaderValue(context,value,header,filter,isHeaderNameFilter){return utils.isFunction(filter)?filter.call(this,value,header):(isHeaderNameFilter&&(value=header),utils.isString(value)?utils.isString(filter)?-1!==value.indexOf(filter):utils.isRegExp(filter)?filter.test(value):void 0:void 0)}class AxiosHeaders{constructor(headers){headers&&this.set(headers)}set(header,valueOrRewrite,rewrite){const self=this;function setHeader(_value,_header,_rewrite){const lHeader=normalizeHeader(_header);if(!lHeader)throw new Error("header name must be a non-empty string");const key=utils.findKey(self,lHeader);(!key||void 0===self[key]||!0===_rewrite||void 0===_rewrite&&!1!==self[key])&&(self[key||_header]=normalizeValue(_value))}const setHeaders=(headers,_rewrite)=>utils.forEach(headers,((_value,_header)=>setHeader(_value,_header,_rewrite)));return utils.isPlainObject(header)||header instanceof this.constructor?setHeaders(header,valueOrRewrite):utils.isString(header)&&(header=header.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(header.trim())?setHeaders((rawHeaders=>{const parsed={};let key,val,i;return rawHeaders&&rawHeaders.split("\n").forEach((function parser(line){i=line.indexOf(":"),key=line.substring(0,i).trim().toLowerCase(),val=line.substring(i+1).trim(),!key||parsed[key]&&ignoreDuplicateOf[key]||("set-cookie"===key?parsed[key]?parsed[key].push(val):parsed[key]=[val]:parsed[key]=parsed[key]?parsed[key]+", "+val:val)})),parsed})(header),valueOrRewrite):null!=header&&setHeader(valueOrRewrite,header,rewrite),this}get(header,parser){if(header=normalizeHeader(header)){const key=utils.findKey(this,header);if(key){const value=this[key];if(!parser)return value;if(!0===parser)return function parseTokens(str){const tokens=Object.create(null),tokensRE=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;let match;for(;match=tokensRE.exec(str);)tokens[match[1]]=match[2];return tokens}(value);if(utils.isFunction(parser))return parser.call(this,value,key);if(utils.isRegExp(parser))return parser.exec(value);throw new TypeError("parser must be boolean|regexp|function")}}}has(header,matcher){if(header=normalizeHeader(header)){const key=utils.findKey(this,header);return!(!key||void 0===this[key]||matcher&&!matchHeaderValue(0,this[key],key,matcher))}return!1}delete(header,matcher){const self=this;let deleted=!1;function deleteHeader(_header){if(_header=normalizeHeader(_header)){const key=utils.findKey(self,_header);!key||matcher&&!matchHeaderValue(0,self[key],key,matcher)||(delete self[key],deleted=!0)}}return utils.isArray(header)?header.forEach(deleteHeader):deleteHeader(header),deleted}clear(matcher){const keys=Object.keys(this);let i=keys.length,deleted=!1;for(;i--;){const key=keys[i];matcher&&!matchHeaderValue(0,this[key],key,matcher,!0)||(delete this[key],deleted=!0)}return deleted}normalize(format){const self=this,headers={};return utils.forEach(this,((value,header)=>{const key=utils.findKey(headers,header);if(key)return self[key]=normalizeValue(value),void delete self[header];const normalized=format?function formatHeader(header){return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,((w,char,str)=>char.toUpperCase()+str))}(header):String(header).trim();normalized!==header&&delete self[header],self[normalized]=normalizeValue(value),headers[normalized]=!0})),this}concat(...targets){return this.constructor.concat(this,...targets)}toJSON(asStrings){const obj=Object.create(null);return utils.forEach(this,((value,header)=>{null!=value&&!1!==value&&(obj[header]=asStrings&&utils.isArray(value)?value.join(", "):value)})),obj}[Symbol.iterator](){return Object.entries(this.toJSON())[Symbol.iterator]()}toString(){return Object.entries(this.toJSON()).map((([header,value])=>header+": "+value)).join("\n")}get[Symbol.toStringTag](){return"AxiosHeaders"}static from(thing){return thing instanceof this?thing:new this(thing)}static concat(first,...targets){const computed=new this(first);return targets.forEach((target=>computed.set(target))),computed}static accessor(header){const accessors=(this[$internals]=this[$internals]={accessors:{}}).accessors,prototype=this.prototype;function defineAccessor(_header){const lHeader=normalizeHeader(_header);accessors[lHeader]||(!function buildAccessors(obj,header){const accessorName=utils.toCamelCase(" "+header);["get","set","has"].forEach((methodName=>{Object.defineProperty(obj,methodName+accessorName,{value:function(arg1,arg2,arg3){return this[methodName].call(this,header,arg1,arg2,arg3)},configurable:!0})}))}(prototype,_header),accessors[lHeader]=!0)}return utils.isArray(header)?header.forEach(defineAccessor):defineAccessor(header),this}}AxiosHeaders.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),utils.freezeMethods(AxiosHeaders.prototype),utils.freezeMethods(AxiosHeaders);var core_AxiosHeaders=AxiosHeaders;function transformData(fns,response){const config=this||lib_defaults,context=response||config,headers=core_AxiosHeaders.from(context.headers);let data=context.data;return utils.forEach(fns,(function transform(fn){data=fn.call(config,data,headers.normalize(),response?response.status:void 0)})),headers.normalize(),data}function isCancel(value){return!(!value||!value.__CANCEL__)}function CanceledError(message,config,request){core_AxiosError.call(this,null==message?"canceled":message,core_AxiosError.ERR_CANCELED,config,request),this.name="CanceledError"}utils.inherits(CanceledError,core_AxiosError,{__CANCEL__:!0});var cancel_CanceledError=CanceledError;var cookies=browser.isStandardBrowserEnv?function standardBrowserEnv(){return{write:function write(name,value,expires,path,domain,secure){const cookie=[];cookie.push(name+"="+encodeURIComponent(value)),utils.isNumber(expires)&&cookie.push("expires="+new Date(expires).toGMTString()),utils.isString(path)&&cookie.push("path="+path),utils.isString(domain)&&cookie.push("domain="+domain),!0===secure&&cookie.push("secure"),document.cookie=cookie.join("; ")},read:function read(name){const match=document.cookie.match(new RegExp("(^|;\\s*)("+name+")=([^;]*)"));return match?decodeURIComponent(match[3]):null},remove:function remove(name){this.write(name,"",Date.now()-864e5)}}}():{write:function write(){},read:function read(){return null},remove:function remove(){}};function buildFullPath(baseURL,requestedURL){return baseURL&&!function isAbsoluteURL(url){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)}(requestedURL)?function combineURLs(baseURL,relativeURL){return relativeURL?baseURL.replace(/\/+$/,"")+"/"+relativeURL.replace(/^\/+/,""):baseURL}(baseURL,requestedURL):requestedURL}var isURLSameOrigin=browser.isStandardBrowserEnv?function standardBrowserEnv(){const msie=/(msie|trident)/i.test(navigator.userAgent),urlParsingNode=document.createElement("a");let originURL;function resolveURL(url){let href=url;return msie&&(urlParsingNode.setAttribute("href",href),href=urlParsingNode.href),urlParsingNode.setAttribute("href",href),{href:urlParsingNode.href,protocol:urlParsingNode.protocol?urlParsingNode.protocol.replace(/:$/,""):"",host:urlParsingNode.host,search:urlParsingNode.search?urlParsingNode.search.replace(/^\?/,""):"",hash:urlParsingNode.hash?urlParsingNode.hash.replace(/^#/,""):"",hostname:urlParsingNode.hostname,port:urlParsingNode.port,pathname:"/"===urlParsingNode.pathname.charAt(0)?urlParsingNode.pathname:"/"+urlParsingNode.pathname}}return originURL=resolveURL(window.location.href),function isURLSameOrigin(requestURL){const parsed=utils.isString(requestURL)?resolveURL(requestURL):requestURL;return parsed.protocol===originURL.protocol&&parsed.host===originURL.host}}():function isURLSameOrigin(){return!0};var helpers_speedometer=function speedometer(samplesCount,min){samplesCount=samplesCount||10;const bytes=new Array(samplesCount),timestamps=new Array(samplesCount);let firstSampleTS,head=0,tail=0;return min=void 0!==min?min:1e3,function push(chunkLength){const now=Date.now(),startedAt=timestamps[tail];firstSampleTS||(firstSampleTS=now),bytes[head]=chunkLength,timestamps[head]=now;let i=tail,bytesCount=0;for(;i!==head;)bytesCount+=bytes[i++],i%=samplesCount;if(head=(head+1)%samplesCount,head===tail&&(tail=(tail+1)%samplesCount),now-firstSampleTS<min)return;const passed=startedAt&&now-startedAt;return passed?Math.round(1e3*bytesCount/passed):void 0}};function progressEventReducer(listener,isDownloadStream){let bytesNotified=0;const _speedometer=helpers_speedometer(50,250);return e=>{const loaded=e.loaded,total=e.lengthComputable?e.total:void 0,progressBytes=loaded-bytesNotified,rate=_speedometer(progressBytes);bytesNotified=loaded;const data={loaded:loaded,total:total,progress:total?loaded/total:void 0,bytes:progressBytes,rate:rate||void 0,estimated:rate&&total&&loaded<=total?(total-loaded)/rate:void 0,event:e};data[isDownloadStream?"download":"upload"]=!0,listener(data)}}const knownAdapters={http:null,xhr:"undefined"!=typeof XMLHttpRequest&&function(config){return new Promise((function dispatchXhrRequest(resolve,reject){let requestData=config.data;const requestHeaders=core_AxiosHeaders.from(config.headers).normalize(),responseType=config.responseType;let onCanceled;function done(){config.cancelToken&&config.cancelToken.unsubscribe(onCanceled),config.signal&&config.signal.removeEventListener("abort",onCanceled)}utils.isFormData(requestData)&&(browser.isStandardBrowserEnv||browser.isStandardBrowserWebWorkerEnv?requestHeaders.setContentType(!1):requestHeaders.setContentType("multipart/form-data;",!1));let request=new XMLHttpRequest;if(config.auth){const username=config.auth.username||"",password=config.auth.password?unescape(encodeURIComponent(config.auth.password)):"";requestHeaders.set("Authorization","Basic "+btoa(username+":"+password))}const fullPath=buildFullPath(config.baseURL,config.url);function onloadend(){if(!request)return;const responseHeaders=core_AxiosHeaders.from("getAllResponseHeaders"in request&&request.getAllResponseHeaders());!function settle(resolve,reject,response){const validateStatus=response.config.validateStatus;response.status&&validateStatus&&!validateStatus(response.status)?reject(new core_AxiosError("Request failed with status code "+response.status,[core_AxiosError.ERR_BAD_REQUEST,core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status/100)-4],response.config,response.request,response)):resolve(response)}((function _resolve(value){resolve(value),done()}),(function _reject(err){reject(err),done()}),{data:responseType&&"text"!==responseType&&"json"!==responseType?request.response:request.responseText,status:request.status,statusText:request.statusText,headers:responseHeaders,config:config,request:request}),request=null}if(request.open(config.method.toUpperCase(),buildURL(fullPath,config.params,config.paramsSerializer),!0),request.timeout=config.timeout,"onloadend"in request?request.onloadend=onloadend:request.onreadystatechange=function handleLoad(){request&&4===request.readyState&&(0!==request.status||request.responseURL&&0===request.responseURL.indexOf("file:"))&&setTimeout(onloadend)},request.onabort=function handleAbort(){request&&(reject(new core_AxiosError("Request aborted",core_AxiosError.ECONNABORTED,config,request)),request=null)},request.onerror=function handleError(){reject(new core_AxiosError("Network Error",core_AxiosError.ERR_NETWORK,config,request)),request=null},request.ontimeout=function handleTimeout(){let timeoutErrorMessage=config.timeout?"timeout of "+config.timeout+"ms exceeded":"timeout exceeded";const transitional=config.transitional||defaults_transitional;config.timeoutErrorMessage&&(timeoutErrorMessage=config.timeoutErrorMessage),reject(new core_AxiosError(timeoutErrorMessage,transitional.clarifyTimeoutError?core_AxiosError.ETIMEDOUT:core_AxiosError.ECONNABORTED,config,request)),request=null},browser.isStandardBrowserEnv){const xsrfValue=(config.withCredentials||isURLSameOrigin(fullPath))&&config.xsrfCookieName&&cookies.read(config.xsrfCookieName);xsrfValue&&requestHeaders.set(config.xsrfHeaderName,xsrfValue)}void 0===requestData&&requestHeaders.setContentType(null),"setRequestHeader"in request&&utils.forEach(requestHeaders.toJSON(),(function setRequestHeader(val,key){request.setRequestHeader(key,val)})),utils.isUndefined(config.withCredentials)||(request.withCredentials=!!config.withCredentials),responseType&&"json"!==responseType&&(request.responseType=config.responseType),"function"==typeof config.onDownloadProgress&&request.addEventListener("progress",progressEventReducer(config.onDownloadProgress,!0)),"function"==typeof config.onUploadProgress&&request.upload&&request.upload.addEventListener("progress",progressEventReducer(config.onUploadProgress)),(config.cancelToken||config.signal)&&(onCanceled=cancel=>{request&&(reject(!cancel||cancel.type?new cancel_CanceledError(null,config,request):cancel),request.abort(),request=null)},config.cancelToken&&config.cancelToken.subscribe(onCanceled),config.signal&&(config.signal.aborted?onCanceled():config.signal.addEventListener("abort",onCanceled)));const protocol=function parseProtocol(url){const match=/^([-+\w]{1,25})(:?\/\/|:)/.exec(url);return match&&match[1]||""}(fullPath);protocol&&-1===browser.protocols.indexOf(protocol)?reject(new core_AxiosError("Unsupported protocol "+protocol+":",core_AxiosError.ERR_BAD_REQUEST,config)):request.send(requestData||null)}))}};utils.forEach(knownAdapters,((fn,value)=>{if(fn){try{Object.defineProperty(fn,"name",{value:value})}catch(e){}Object.defineProperty(fn,"adapterName",{value:value})}}));var adapters_getAdapter=adapters=>{adapters=utils.isArray(adapters)?adapters:[adapters];const{length:length}=adapters;let nameOrAdapter,adapter;for(let i=0;i<length&&(nameOrAdapter=adapters[i],!(adapter=utils.isString(nameOrAdapter)?knownAdapters[nameOrAdapter.toLowerCase()]:nameOrAdapter));i++);if(!adapter){if(!1===adapter)throw new core_AxiosError(`Adapter ${nameOrAdapter} is not supported by the environment`,"ERR_NOT_SUPPORT");throw new Error(utils.hasOwnProp(knownAdapters,nameOrAdapter)?`Adapter '${nameOrAdapter}' is not available in the build`:`Unknown adapter '${nameOrAdapter}'`)}if(!utils.isFunction(adapter))throw new TypeError("adapter is not a function");return adapter};function throwIfCancellationRequested(config){if(config.cancelToken&&config.cancelToken.throwIfRequested(),config.signal&&config.signal.aborted)throw new cancel_CanceledError(null,config)}function dispatchRequest(config){throwIfCancellationRequested(config),config.headers=core_AxiosHeaders.from(config.headers),config.data=transformData.call(config,config.transformRequest),-1!==["post","put","patch"].indexOf(config.method)&&config.headers.setContentType("application/x-www-form-urlencoded",!1);return adapters_getAdapter(config.adapter||lib_defaults.adapter)(config).then((function onAdapterResolution(response){return throwIfCancellationRequested(config),response.data=transformData.call(config,config.transformResponse,response),response.headers=core_AxiosHeaders.from(response.headers),response}),(function onAdapterRejection(reason){return isCancel(reason)||(throwIfCancellationRequested(config),reason&&reason.response&&(reason.response.data=transformData.call(config,config.transformResponse,reason.response),reason.response.headers=core_AxiosHeaders.from(reason.response.headers))),Promise.reject(reason)}))}const headersToObject=thing=>thing instanceof core_AxiosHeaders?thing.toJSON():thing;function mergeConfig(config1,config2){config2=config2||{};const config={};function getMergedValue(target,source,caseless){return utils.isPlainObject(target)&&utils.isPlainObject(source)?utils.merge.call({caseless:caseless},target,source):utils.isPlainObject(source)?utils.merge({},source):utils.isArray(source)?source.slice():source}function mergeDeepProperties(a,b,caseless){return utils.isUndefined(b)?utils.isUndefined(a)?void 0:getMergedValue(void 0,a,caseless):getMergedValue(a,b,caseless)}function valueFromConfig2(a,b){if(!utils.isUndefined(b))return getMergedValue(void 0,b)}function defaultToConfig2(a,b){return utils.isUndefined(b)?utils.isUndefined(a)?void 0:getMergedValue(void 0,a):getMergedValue(void 0,b)}function mergeDirectKeys(a,b,prop){return prop in config2?getMergedValue(a,b):prop in config1?getMergedValue(void 0,a):void 0}const mergeMap={url:valueFromConfig2,method:valueFromConfig2,data:valueFromConfig2,baseURL:defaultToConfig2,transformRequest:defaultToConfig2,transformResponse:defaultToConfig2,paramsSerializer:defaultToConfig2,timeout:defaultToConfig2,timeoutMessage:defaultToConfig2,withCredentials:defaultToConfig2,adapter:defaultToConfig2,responseType:defaultToConfig2,xsrfCookieName:defaultToConfig2,xsrfHeaderName:defaultToConfig2,onUploadProgress:defaultToConfig2,onDownloadProgress:defaultToConfig2,decompress:defaultToConfig2,maxContentLength:defaultToConfig2,maxBodyLength:defaultToConfig2,beforeRedirect:defaultToConfig2,transport:defaultToConfig2,httpAgent:defaultToConfig2,httpsAgent:defaultToConfig2,cancelToken:defaultToConfig2,socketPath:defaultToConfig2,responseEncoding:defaultToConfig2,validateStatus:mergeDirectKeys,headers:(a,b)=>mergeDeepProperties(headersToObject(a),headersToObject(b),!0)};return utils.forEach(Object.keys(Object.assign({},config1,config2)),(function computeConfigValue(prop){const merge=mergeMap[prop]||mergeDeepProperties,configValue=merge(config1[prop],config2[prop],prop);utils.isUndefined(configValue)&&merge!==mergeDirectKeys||(config[prop]=configValue)})),config}const validators={};["object","boolean","number","function","string","symbol"].forEach(((type,i)=>{validators[type]=function validator(thing){return typeof thing===type||"a"+(i<1?"n ":" ")+type}}));const deprecatedWarnings={};validators.transitional=function transitional(validator,version,message){function formatMessage(opt,desc){return"[Axios v1.4.0] Transitional option '"+opt+"'"+desc+(message?". "+message:"")}return(value,opt,opts)=>{if(!1===validator)throw new core_AxiosError(formatMessage(opt," has been removed"+(version?" in "+version:"")),core_AxiosError.ERR_DEPRECATED);return version&&!deprecatedWarnings[opt]&&(deprecatedWarnings[opt]=!0,console.warn(formatMessage(opt," has been deprecated since v"+version+" and will be removed in the near future"))),!validator||validator(value,opt,opts)}};var validator={assertOptions:function assertOptions(options,schema,allowUnknown){if("object"!=typeof options)throw new core_AxiosError("options must be an object",core_AxiosError.ERR_BAD_OPTION_VALUE);const keys=Object.keys(options);let i=keys.length;for(;i-- >0;){const opt=keys[i],validator=schema[opt];if(validator){const value=options[opt],result=void 0===value||validator(value,opt,options);if(!0!==result)throw new core_AxiosError("option "+opt+" must be "+result,core_AxiosError.ERR_BAD_OPTION_VALUE)}else if(!0!==allowUnknown)throw new core_AxiosError("Unknown option "+opt,core_AxiosError.ERR_BAD_OPTION)}},validators:validators};const Axios_validators=validator.validators;class Axios{constructor(instanceConfig){this.defaults=instanceConfig,this.interceptors={request:new core_InterceptorManager,response:new core_InterceptorManager}}request(configOrUrl,config){"string"==typeof configOrUrl?(config=config||{}).url=configOrUrl:config=configOrUrl||{},config=mergeConfig(this.defaults,config);const{transitional:transitional,paramsSerializer:paramsSerializer,headers:headers}=config;let contextHeaders;void 0!==transitional&&validator.assertOptions(transitional,{silentJSONParsing:Axios_validators.transitional(Axios_validators.boolean),forcedJSONParsing:Axios_validators.transitional(Axios_validators.boolean),clarifyTimeoutError:Axios_validators.transitional(Axios_validators.boolean)},!1),null!=paramsSerializer&&(utils.isFunction(paramsSerializer)?config.paramsSerializer={serialize:paramsSerializer}:validator.assertOptions(paramsSerializer,{encode:Axios_validators.function,serialize:Axios_validators.function},!0)),config.method=(config.method||this.defaults.method||"get").toLowerCase(),contextHeaders=headers&&utils.merge(headers.common,headers[config.method]),contextHeaders&&utils.forEach(["delete","get","head","post","put","patch","common"],(method=>{delete headers[method]})),config.headers=core_AxiosHeaders.concat(contextHeaders,headers);const requestInterceptorChain=[];let synchronousRequestInterceptors=!0;this.interceptors.request.forEach((function unshiftRequestInterceptors(interceptor){"function"==typeof interceptor.runWhen&&!1===interceptor.runWhen(config)||(synchronousRequestInterceptors=synchronousRequestInterceptors&&interceptor.synchronous,requestInterceptorChain.unshift(interceptor.fulfilled,interceptor.rejected))}));const responseInterceptorChain=[];let promise;this.interceptors.response.forEach((function pushResponseInterceptors(interceptor){responseInterceptorChain.push(interceptor.fulfilled,interceptor.rejected)}));let len,i=0;if(!synchronousRequestInterceptors){const chain=[dispatchRequest.bind(this),void 0];for(chain.unshift.apply(chain,requestInterceptorChain),chain.push.apply(chain,responseInterceptorChain),len=chain.length,promise=Promise.resolve(config);i<len;)promise=promise.then(chain[i++],chain[i++]);return promise}len=requestInterceptorChain.length;let newConfig=config;for(i=0;i<len;){const onFulfilled=requestInterceptorChain[i++],onRejected=requestInterceptorChain[i++];try{newConfig=onFulfilled(newConfig)}catch(error){onRejected.call(this,error);break}}try{promise=dispatchRequest.call(this,newConfig)}catch(error){return Promise.reject(error)}for(i=0,len=responseInterceptorChain.length;i<len;)promise=promise.then(responseInterceptorChain[i++],responseInterceptorChain[i++]);return promise}getUri(config){return buildURL(buildFullPath((config=mergeConfig(this.defaults,config)).baseURL,config.url),config.params,config.paramsSerializer)}}utils.forEach(["delete","get","head","options"],(function forEachMethodNoData(method){Axios.prototype[method]=function(url,config){return this.request(mergeConfig(config||{},{method:method,url:url,data:(config||{}).data}))}})),utils.forEach(["post","put","patch"],(function forEachMethodWithData(method){function generateHTTPMethod(isForm){return function httpMethod(url,data,config){return this.request(mergeConfig(config||{},{method:method,headers:isForm?{"Content-Type":"multipart/form-data"}:{},url:url,data:data}))}}Axios.prototype[method]=generateHTTPMethod(),Axios.prototype[method+"Form"]=generateHTTPMethod(!0)}));var core_Axios=Axios;class CancelToken{constructor(executor){if("function"!=typeof executor)throw new TypeError("executor must be a function.");let resolvePromise;this.promise=new Promise((function promiseExecutor(resolve){resolvePromise=resolve}));const token=this;this.promise.then((cancel=>{if(!token._listeners)return;let i=token._listeners.length;for(;i-- >0;)token._listeners[i](cancel);token._listeners=null})),this.promise.then=onfulfilled=>{let _resolve;const promise=new Promise((resolve=>{token.subscribe(resolve),_resolve=resolve})).then(onfulfilled);return promise.cancel=function reject(){token.unsubscribe(_resolve)},promise},executor((function cancel(message,config,request){token.reason||(token.reason=new cancel_CanceledError(message,config,request),resolvePromise(token.reason))}))}throwIfRequested(){if(this.reason)throw this.reason}subscribe(listener){this.reason?listener(this.reason):this._listeners?this._listeners.push(listener):this._listeners=[listener]}unsubscribe(listener){if(!this._listeners)return;const index=this._listeners.indexOf(listener);-1!==index&&this._listeners.splice(index,1)}static source(){let cancel;return{token:new CancelToken((function executor(c){cancel=c})),cancel:cancel}}}var cancel_CancelToken=CancelToken;const HttpStatusCode={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(HttpStatusCode).forEach((([key,value])=>{HttpStatusCode[value]=key}));var helpers_HttpStatusCode=HttpStatusCode;const axios=function createInstance(defaultConfig){const context=new core_Axios(defaultConfig),instance=bind(core_Axios.prototype.request,context);return utils.extend(instance,core_Axios.prototype,context,{allOwnKeys:!0}),utils.extend(instance,context,null,{allOwnKeys:!0}),instance.create=function create(instanceConfig){return createInstance(mergeConfig(defaultConfig,instanceConfig))},instance}(lib_defaults);axios.Axios=core_Axios,axios.CanceledError=cancel_CanceledError,axios.CancelToken=cancel_CancelToken,axios.isCancel=isCancel,axios.VERSION="1.4.0",axios.toFormData=helpers_toFormData,axios.AxiosError=core_AxiosError,axios.Cancel=axios.CanceledError,axios.all=function all(promises){return Promise.all(promises)},axios.spread=function spread(callback){return function wrap(arr){return callback.apply(null,arr)}},axios.isAxiosError=function isAxiosError(payload){return utils.isObject(payload)&&!0===payload.isAxiosError},axios.mergeConfig=mergeConfig,axios.AxiosHeaders=core_AxiosHeaders,axios.formToJSON=thing=>helpers_formDataToJSON(utils.isHTMLForm(thing)?new FormData(thing):thing),axios.HttpStatusCode=helpers_HttpStatusCode,axios.default=axios;var lib_axios=axios},"./node_modules/react-tiny-dialog/dist/index.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{V:function(){return Dialog}});var jsx_runtime=__webpack_require__("./node_modules/react/jsx-runtime.js"),react=__webpack_require__("./node_modules/react/index.js"),react_dom=__webpack_require__("./node_modules/react-dom/index.js");var hooks_useContextInScope=context=>{const value=(0,react.useContext)(context);if(!value.inScope)throw new Error(`Must use in ${context.displayName||"root component"}`);return value};function useDialog(opened=!1){const[isOpened,openDialog,closeDialog]=function useBoolean(init=!1){const[boolean,setBoolean]=(0,react.useState)(init);return[boolean,(0,react.useCallback)((()=>setBoolean(!0)),[]),(0,react.useCallback)((()=>setBoolean(!1)),[]),(0,react.useCallback)((()=>setBoolean((prev=>!prev))),[])]}(opened),closeWithEscape=(0,react.useCallback)((e=>{"Escape"===e.key&&closeDialog()}),[]);return(0,react.useEffect)((()=>(isOpened?document.addEventListener("keydown",closeWithEscape):document.removeEventListener("keydown",closeWithEscape),()=>document.removeEventListener("keydown",closeWithEscape))),[isOpened]),{isOpened:isOpened,openDialog:openDialog,closeDialog:closeDialog,closeWithEscape:closeWithEscape}}const composeEventHandlers=(externalEventHandler,innerEventHandler)=>event=>{null==externalEventHandler||externalEventHandler(event),null==innerEventHandler||innerEventHandler(event)},preventScroll=opened=>{document.body.style.overflow=opened?"hidden":"auto"},DialogContext=(0,react.createContext)({isOpened:!1,inScope:!1,openHandler(){}});DialogContext.displayName="Dialog";const useDialogContext=()=>hooks_useContextInScope(DialogContext);function DialogProvider(props){const{value:{open:open,defaultOpen:defaultOpen,scroll:scroll=!1,onOpenChange:onOpenChange},children:children}=props,{isOpened:isOpened,openDialog:openDialog,closeDialog:closeDialog}=useDialog(null!=open?open:defaultOpen),composedDialogState=null!=open?open:isOpened;return(0,react.useEffect)((()=>{scroll||preventScroll(composedDialogState)}),[scroll,composedDialogState]),(0,react.useEffect)((()=>{null==onOpenChange||onOpenChange(isOpened)}),[isOpened]),(0,jsx_runtime.jsx)(DialogContext.Provider,Object.assign({value:{isOpened:composedDialogState,inScope:!0,openHandler:()=>{isOpened?closeDialog():openDialog()}}},{children:children}))}const getValidChildAsChild=children=>{const child=react.Children.only(children);return(0,react.isValidElement)(child)?child:null};function getValidProps(props){if(props.asChild){const firstChild=getValidChildAsChild(props.children);if(firstChild)return Object.assign(Object.assign({},props),{asChild:props.asChild,firstChild:firstChild})}return Object.assign(Object.assign({},props),{asChild:!1,firstChild:null})}var Dialog_module_Trigger="Dialog_Trigger__DccAI",Dialog_module_BackDrop="Dialog_BackDrop__PJWqE",Dialog_module_Close="Dialog_Close__wBgoK",Dialog_module_Content="Dialog_Content__k61Vn",__rest=function(s,e){var t={};for(var p in s)Object.prototype.hasOwnProperty.call(s,p)&&e.indexOf(p)<0&&(t[p]=s[p]);if(null!=s&&"function"==typeof Object.getOwnPropertySymbols){var i=0;for(p=Object.getOwnPropertySymbols(s);i<p.length;i++)e.indexOf(p[i])<0&&Object.prototype.propertyIsEnumerable.call(s,p[i])&&(t[p[i]]=s[p[i]])}return t};function Dialog(props){const{children:children}=props,restProps=__rest(props,["children"]);return(0,jsx_runtime.jsx)(DialogProvider,Object.assign({value:restProps},{children:children}))}Dialog.Trigger=function Trigger(props){const _a=getValidProps(props),{asChild:asChild,firstChild:firstChild,children:children="Trigger",onClick:onClickProps}=_a,restProps=__rest(_a,["asChild","firstChild","children","onClick"]),{openHandler:openHandler}=useDialogContext();return asChild?(0,react.cloneElement)(firstChild,Object.assign(Object.assign({},restProps),{onClick:composeEventHandlers(onClickProps,openHandler)})):(0,jsx_runtime.jsx)("button",Object.assign({},restProps,{onClick:composeEventHandlers(onClickProps,openHandler),className:Dialog_module_Trigger},{children:children}))},Dialog.Portal=function Portal({children:children,container:container=document.body}){const{isOpened:isOpened}=useDialogContext();return isOpened?(0,react_dom.createPortal)(children,container):null},Dialog.BackDrop=function BackDrop(props){const _a=getValidProps(props),{asChild:asChild,firstChild:firstChild,children:children,onClick:onClickProps}=_a,restProps=__rest(_a,["asChild","firstChild","children","onClick"]),{isOpened:isOpened,openHandler:openHandler}=useDialogContext(),backDrop=asChild?(0,react.cloneElement)(firstChild,Object.assign(Object.assign({},restProps),{onClick:composeEventHandlers(onClickProps,openHandler)})):(0,jsx_runtime.jsx)("div",Object.assign({},restProps,{onClick:composeEventHandlers(onClickProps,openHandler),className:Dialog_module_BackDrop}));return isOpened?backDrop:null},Dialog.Content=function Content(props){const _a=getValidProps(props),{asChild:asChild,firstChild:firstChild,children:children}=_a,restProps=__rest(_a,["asChild","firstChild","children"]),{isOpened:isOpened}=useDialogContext(),content=asChild?(0,react.cloneElement)(firstChild,Object.assign({},restProps)):(0,jsx_runtime.jsx)("div",Object.assign({},restProps,{className:Dialog_module_Content},{children:children}));return isOpened?content:null},Dialog.Close=function Close(props){const _a=getValidProps(props),{asChild:asChild,firstChild:firstChild,children:children="X",onClick:onClickProps}=_a,restProps=__rest(_a,["asChild","firstChild","children","onClick"]),{isOpened:isOpened,openHandler:openHandler}=useDialogContext(),close=asChild?(0,react.cloneElement)(firstChild,Object.assign(Object.assign({},restProps),{onClick:composeEventHandlers(onClickProps,openHandler)})):(0,jsx_runtime.jsx)("button",Object.assign({},restProps,{onClick:composeEventHandlers(onClickProps,openHandler),className:Dialog_module_Close},{children:children}));return isOpened?close:null}},"./node_modules/recoil/es/index.js":function(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{CG:function(){return Recoil_index_11},Wh:function(){return Recoil_index_5},Zl:function(){return Recoil_index_24},cn:function(){return Recoil_index_8},nZ:function(){return Recoil_index_9},sJ:function(){return Recoil_index_20}});var react__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/react/index.js"),react_dom__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/react-dom/index.js"),process=__webpack_require__("./node_modules/process/browser.js");var Recoil_err=function err(message){const error=new Error(message);if(void 0===error.stack)try{throw error}catch(_){}return error};var Recoil_isPromise=function isPromise(p){return!!p&&"function"==typeof p.then};var Recoil_nullthrows=function nullthrows(x,message){if(null!=x)return x;throw Recoil_err(null!=message?message:"Got unexpected null or undefined")};function _defineProperty(obj,key,value){return key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}class BaseLoadable{getValue(){throw Recoil_err("BaseLoadable")}toPromise(){throw Recoil_err("BaseLoadable")}valueMaybe(){throw Recoil_err("BaseLoadable")}valueOrThrow(){throw Recoil_err(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw Recoil_err("BaseLoadable")}promiseOrThrow(){throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw Recoil_err("BaseLoadable")}errorOrThrow(){throw Recoil_err(`Loadable expected error, but in "${this.state}" state`)}is(other){return other.state===this.state&&other.contents===this.contents}map(_map){throw Recoil_err("BaseLoadable")}}class ValueLoadable extends BaseLoadable{constructor(value){super(),_defineProperty(this,"state","hasValue"),_defineProperty(this,"contents",void 0),this.contents=value}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(map){try{const next=map(this.contents);return Recoil_isPromise(next)?loadableWithPromise(next):isLoadable(next)?next:loadableWithValue(next)}catch(e){return Recoil_isPromise(e)?loadableWithPromise(e.next((()=>this.map(map)))):loadableWithError(e)}}}class ErrorLoadable extends BaseLoadable{constructor(error){super(),_defineProperty(this,"state","hasError"),_defineProperty(this,"contents",void 0),this.contents=error}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(_map){return this}}class LoadingLoadable extends BaseLoadable{constructor(promise){super(),_defineProperty(this,"state","loading"),_defineProperty(this,"contents",void 0),this.contents=promise}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(map){return loadableWithPromise(this.contents.then((value=>{const next=map(value);if(isLoadable(next)){const nextLoadable=next;switch(nextLoadable.state){case"hasValue":case"loading":return nextLoadable.contents;case"hasError":throw nextLoadable.contents}}return next})).catch((e=>{if(Recoil_isPromise(e))return e.then((()=>this.map(map).contents));throw e})))}}function loadableWithValue(value){return Object.freeze(new ValueLoadable(value))}function loadableWithError(error){return Object.freeze(new ErrorLoadable(error))}function loadableWithPromise(promise){return Object.freeze(new LoadingLoadable(promise))}function loadableLoading(){return Object.freeze(new LoadingLoadable(new Promise((()=>{}))))}function loadableAll(inputs){const output=function loadableAllArray(inputs){return inputs.every((i=>"hasValue"===i.state))?loadableWithValue(inputs.map((i=>i.contents))):inputs.some((i=>"hasError"===i.state))?loadableWithError(Recoil_nullthrows(inputs.find((i=>"hasError"===i.state)),"Invalid loadable passed to loadableAll").contents):loadableWithPromise(Promise.all(inputs.map((i=>i.contents))))}((Array.isArray(inputs)?inputs:Object.getOwnPropertyNames(inputs).map((key=>inputs[key]))).map((x=>isLoadable(x)?x:Recoil_isPromise(x)?loadableWithPromise(x):loadableWithValue(x))));return Array.isArray(inputs)?output:output.map((outputs=>Object.getOwnPropertyNames(inputs).reduce(((out,key,idx)=>({...out,[key]:outputs[idx]})),{})))}function isLoadable(x){return x instanceof BaseLoadable}const LoadableStaticInterface={of:value=>Recoil_isPromise(value)?loadableWithPromise(value):isLoadable(value)?value:loadableWithValue(value),error:error=>loadableWithError(error),loading:()=>loadableLoading(),all:loadableAll,isLoadable:isLoadable};var Recoil_Loadable={loadableWithValue:loadableWithValue,loadableWithError:loadableWithError,loadableWithPromise:loadableWithPromise,loadableLoading:loadableLoading,loadableAll:loadableAll,isLoadable:isLoadable,RecoilLoadable:LoadableStaticInterface},Recoil_Loadable_1=Recoil_Loadable.loadableWithValue,Recoil_Loadable_2=Recoil_Loadable.loadableWithError,Recoil_Loadable_3=Recoil_Loadable.loadableWithPromise,Recoil_Loadable_4=Recoil_Loadable.loadableLoading,Recoil_Loadable_5=Recoil_Loadable.loadableAll,Recoil_Loadable_6=Recoil_Loadable.isLoadable,Recoil_Loadable_7=Recoil_Loadable.RecoilLoadable,Recoil_Loadable$1=Object.freeze({__proto__:null,loadableWithValue:Recoil_Loadable_1,loadableWithError:Recoil_Loadable_2,loadableWithPromise:Recoil_Loadable_3,loadableLoading:Recoil_Loadable_4,loadableAll:Recoil_Loadable_5,isLoadable:Recoil_Loadable_6,RecoilLoadable:Recoil_Loadable_7});const env={RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED:!0,RECOIL_GKS_ENABLED:new Set(["recoil_hamt_2020","recoil_sync_external_store","recoil_suppress_rerender_in_callback","recoil_memory_managament_2020"])};!function applyProcessEnvFlagOverrides(){void 0!==process&&null!=(null===process||void 0===process?void 0:process.env)&&(!function readProcessEnvBooleanFlag(name,set){var _process$env$name,_process$env$name$toL;const sanitizedValue=null===(_process$env$name=process.env[name])||void 0===_process$env$name||null===(_process$env$name$toL=_process$env$name.toLowerCase())||void 0===_process$env$name$toL?void 0:_process$env$name$toL.trim();if(null==sanitizedValue||""===sanitizedValue)return;if(!["true","false"].includes(sanitizedValue))throw Recoil_err(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);set("true"===sanitizedValue)}("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED",(value=>{env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED=value})),function readProcessEnvStringArrayFlag(name,set){var _process$env$name2;const sanitizedValue=null===(_process$env$name2=process.env[name])||void 0===_process$env$name2?void 0:_process$env$name2.trim();null!=sanitizedValue&&""!==sanitizedValue&&set(sanitizedValue.split(/\s*,\s*|\s+/))}("RECOIL_GKS_ENABLED",(value=>{value.forEach((gk=>{env.RECOIL_GKS_ENABLED.add(gk)}))})))}();var Recoil_RecoilEnv=env;function Recoil_gkx_OSS(gk){return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk)}Recoil_gkx_OSS.setPass=gk=>{Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk)},Recoil_gkx_OSS.setFail=gk=>{Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk)},Recoil_gkx_OSS.clear=()=>{Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear()};var Recoil_gkx=Recoil_gkx_OSS;var _createMutableSource,_useMutableSource,_useSyncExternalStore,Recoil_recoverableViolation=function recoverableViolation(message,_projectName,{error:error}={}){return null};const createMutableSource=null!==(_createMutableSource=react__WEBPACK_IMPORTED_MODULE_0__.createMutableSource)&&void 0!==_createMutableSource?_createMutableSource:react__WEBPACK_IMPORTED_MODULE_0__.unstable_createMutableSource,useMutableSource=null!==(_useMutableSource=react__WEBPACK_IMPORTED_MODULE_0__.useMutableSource)&&void 0!==_useMutableSource?_useMutableSource:react__WEBPACK_IMPORTED_MODULE_0__.unstable_useMutableSource,useSyncExternalStore=null!==(_useSyncExternalStore=react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)&&void 0!==_useSyncExternalStore?_useSyncExternalStore:react__WEBPACK_IMPORTED_MODULE_0__.unstable_useSyncExternalStore;let ReactRendererVersionMismatchWarnOnce=!1;var Recoil_ReactMode={createMutableSource:createMutableSource,useMutableSource:useMutableSource,useSyncExternalStore:useSyncExternalStore,currentRendererSupportsUseSyncExternalStore:function currentRendererSupportsUseSyncExternalStore(){var _ReactCurrentDispatch;const{ReactCurrentDispatcher:ReactCurrentDispatcher,ReactCurrentOwner:ReactCurrentOwner}=react__WEBPACK_IMPORTED_MODULE_0__.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,isUseSyncExternalStoreSupported=null!=(null!==(_ReactCurrentDispatch=null==ReactCurrentDispatcher?void 0:ReactCurrentDispatcher.current)&&void 0!==_ReactCurrentDispatch?_ReactCurrentDispatch:ReactCurrentOwner.currentDispatcher).useSyncExternalStore;return!useSyncExternalStore||isUseSyncExternalStoreSupported||ReactRendererVersionMismatchWarnOnce||(ReactRendererVersionMismatchWarnOnce=!0,Recoil_recoverableViolation("A React renderer without React 18+ API support is being used with React 18+.")),isUseSyncExternalStoreSupported},reactMode:function reactMode(){return Recoil_gkx("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:Recoil_gkx("recoil_sync_external_store")&&null!=useSyncExternalStore?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:Recoil_gkx("recoil_mutable_source")&&null!=useMutableSource&&"undefined"!=typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?Recoil_gkx("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:Recoil_gkx("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}},isFastRefreshEnabled:function isFastRefreshEnabled(){return!1}};class AbstractRecoilValue{constructor(newKey){_defineProperty(this,"key",void 0),this.key=newKey}toJSON(){return{key:this.key}}}class RecoilState extends AbstractRecoilValue{}class RecoilValueReadOnly extends AbstractRecoilValue{}var Recoil_RecoilValue={AbstractRecoilValue:AbstractRecoilValue,RecoilState:RecoilState,RecoilValueReadOnly:RecoilValueReadOnly,isRecoilValue:function isRecoilValue(x){return x instanceof RecoilState||x instanceof RecoilValueReadOnly}},Recoil_RecoilValue_1=Recoil_RecoilValue.AbstractRecoilValue,Recoil_RecoilValue_2=Recoil_RecoilValue.RecoilState,Recoil_RecoilValue_3=Recoil_RecoilValue.RecoilValueReadOnly,Recoil_RecoilValue_4=Recoil_RecoilValue.isRecoilValue,Recoil_RecoilValue$1=Object.freeze({__proto__:null,AbstractRecoilValue:Recoil_RecoilValue_1,RecoilState:Recoil_RecoilValue_2,RecoilValueReadOnly:Recoil_RecoilValue_3,isRecoilValue:Recoil_RecoilValue_4});var Recoil_expectationViolation=function expectationViolation(format,...args){0};var Recoil_mapIterable=function mapIterable(iterable,callback){return function*(){let index=0;for(const value of iterable)yield callback(value,index++)}()};const{isFastRefreshEnabled:isFastRefreshEnabled$1}=Recoil_ReactMode;class DefaultValue{}const DEFAULT_VALUE=new DefaultValue,nodes=new Map,recoilValues=new Map;class NodeMissingError extends Error{}const configDeletionHandlers=new Map;function getConfigDeletionHandler(key){return configDeletionHandlers.get(key)}var Recoil_Node={nodes:nodes,recoilValues:recoilValues,registerNode:function registerNode(node){Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED&&function checkForDuplicateAtomKey(key){if(nodes.has(key)){const message=`Duplicate atom key "${key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(message)}}(node.key),nodes.set(node.key,node);const recoilValue=null==node.set?new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key):new Recoil_RecoilValue$1.RecoilState(node.key);return recoilValues.set(node.key,recoilValue),recoilValue},getNode:function getNode(key){const node=nodes.get(key);if(null==node)throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);return node},getNodeMaybe:function getNodeMaybe(key){return nodes.get(key)},deleteNodeConfigIfPossible:function deleteNodeConfigIfPossible(key){var _node$shouldDeleteCon;if(!Recoil_gkx("recoil_memory_managament_2020"))return;const node=nodes.get(key);var _getConfigDeletionHan;null!=node&&null!==(_node$shouldDeleteCon=node.shouldDeleteConfigOnRelease)&&void 0!==_node$shouldDeleteCon&&_node$shouldDeleteCon.call(node)&&(nodes.delete(key),null===(_getConfigDeletionHan=getConfigDeletionHandler(key))||void 0===_getConfigDeletionHan||_getConfigDeletionHan(),configDeletionHandlers.delete(key))},setConfigDeletionHandler:function setConfigDeletionHandler(key,fn){Recoil_gkx("recoil_memory_managament_2020")&&(void 0===fn?configDeletionHandlers.delete(key):configDeletionHandlers.set(key,fn))},getConfigDeletionHandler:getConfigDeletionHandler,recoilValuesForKeys:function recoilValuesForKeys(keys){return Recoil_mapIterable(keys,(key=>Recoil_nullthrows(recoilValues.get(key))))},NodeMissingError:NodeMissingError,DefaultValue:DefaultValue,DEFAULT_VALUE:DEFAULT_VALUE};var Recoil_Queue={enqueueExecution:function enqueueExecution(s,f){f()}};var hamt_1=function createCommonjsModule(fn,module){return fn(module={exports:{}},module.exports),module.exports}((function(module){var _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},hamt={},BUCKET_SIZE=Math.pow(2,5),MASK=BUCKET_SIZE-1,MAX_INDEX_NODE=BUCKET_SIZE/2,MIN_ARRAY_NODE=BUCKET_SIZE/4,nothing={},constant=function constant(x){return function(){return x}},hash=hamt.hash=function(str){var type=void 0===str?"undefined":_typeof(str);if("number"===type)return str;"string"!==type&&(str+="");for(var hash=0,i=0,len=str.length;i<len;++i){hash=(hash<<5)-hash+str.charCodeAt(i)|0}return hash},hashFragment=function hashFragment(shift,h){return h>>>shift&MASK},toBitmap=function toBitmap(x){return 1<<x},fromBitmap=function fromBitmap(bitmap,bit){return function popcount(x){return x=(x=(858993459&(x-=x>>1&1431655765))+(x>>2&858993459))+(x>>4)&252645135,x+=x>>8,127&x+(x>>16)}(bitmap&bit-1)},arrayUpdate=function arrayUpdate(mutate,at,v,arr){var out=arr;if(!mutate){var len=arr.length;out=new Array(len);for(var i=0;i<len;++i)out[i]=arr[i]}return out[at]=v,out},arraySpliceOut=function arraySpliceOut(mutate,at,arr){var newLen=arr.length-1,i=0,g=0,out=arr;if(mutate)i=g=at;else for(out=new Array(newLen);i<at;)out[g++]=arr[i++];for(++i;i<=newLen;)out[g++]=arr[i++];return mutate&&(out.length=newLen),out},empty={__hamt_isEmpty:!0},isEmptyNode=function isEmptyNode(x){return x===empty||x&&x.__hamt_isEmpty},Leaf=function Leaf(edit,hash,key,value){return{type:1,edit:edit,hash:hash,key:key,value:value,_modify:Leaf__modify}},Collision=function Collision(edit,hash,children){return{type:2,edit:edit,hash:hash,children:children,_modify:Collision__modify}},IndexedNode=function IndexedNode(edit,mask,children){return{type:3,edit:edit,mask:mask,children:children,_modify:IndexedNode__modify}},ArrayNode=function ArrayNode(edit,size,children){return{type:4,edit:edit,size:size,children:children,_modify:ArrayNode__modify}},mergeLeaves=function mergeLeaves(edit,shift,h1,n1,h2,n2){if(h1===h2)return Collision(edit,h1,[n2,n1]);var subH1=hashFragment(shift,h1),subH2=hashFragment(shift,h2);return IndexedNode(edit,toBitmap(subH1)|toBitmap(subH2),subH1===subH2?[mergeLeaves(edit,shift+5,h1,n1,h2,n2)]:subH1<subH2?[n1,n2]:[n2,n1])},canEditNode=function canEditNode(edit,node){return edit===node.edit},Leaf__modify=function Leaf__modify(edit,keyEq,shift,f,h,k,size){if(keyEq(k,this.key)){var _v=f(this.value);return _v===this.value?this:_v===nothing?(--size.value,empty):canEditNode(edit,this)?(this.value=_v,this):Leaf(edit,h,k,_v)}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},Collision__modify=function Collision__modify(edit,keyEq,shift,f,h,k,size){if(h===this.hash){var list=function updateCollisionList(mutate,edit,keyEq,h,list,f,k,size){for(var len=list.length,i=0;i<len;++i){var child=list[i];if(keyEq(k,child.key)){var value=child.value,_newValue=f(value);return _newValue===value?list:_newValue===nothing?(--size.value,arraySpliceOut(mutate,i,list)):arrayUpdate(mutate,i,Leaf(edit,h,k,_newValue),list)}}var newValue=f();return newValue===nothing?list:(++size.value,arrayUpdate(mutate,len,Leaf(edit,h,k,newValue),list))}(canEditNode(edit,this),edit,keyEq,this.hash,this.children,f,k,size);return list===this.children?this:list.length>1?Collision(edit,this.hash,list):list[0]}var v=f();return v===nothing?this:(++size.value,mergeLeaves(edit,shift,this.hash,this,h,Leaf(edit,h,k,v)))},IndexedNode__modify=function IndexedNode__modify(edit,keyEq,shift,f,h,k,size){var mask=this.mask,children=this.children,frag=hashFragment(shift,h),bit=toBitmap(frag),indx=fromBitmap(mask,bit),exists=mask&bit,current=exists?children[indx]:empty,child=current._modify(edit,keyEq,shift+5,f,h,k,size);if(current===child)return this;var canEdit=canEditNode(edit,this),bitmap=mask,newChildren=void 0;if(exists&&isEmptyNode(child)){if(!(bitmap&=~bit))return empty;if(children.length<=2&&function isLeaf(node){return node===empty||1===node.type||2===node.type}(children[1^indx]))return children[1^indx];newChildren=arraySpliceOut(canEdit,indx,children)}else if(exists||isEmptyNode(child))newChildren=arrayUpdate(canEdit,indx,child,children);else{if(children.length>=MAX_INDEX_NODE)return function expand(edit,frag,child,bitmap,subNodes){for(var arr=[],bit=bitmap,count=0,i=0;bit;++i)1&bit&&(arr[i]=subNodes[count++]),bit>>>=1;return arr[frag]=child,ArrayNode(edit,count+1,arr)}(edit,frag,child,mask,children);bitmap|=bit,newChildren=function arraySpliceIn(mutate,at,v,arr){var len=arr.length;if(mutate){for(var _i=len;_i>=at;)arr[_i--]=arr[_i];return arr[at]=v,arr}for(var i=0,g=0,out=new Array(len+1);i<at;)out[g++]=arr[i++];for(out[at]=v;i<len;)out[++g]=arr[i++];return out}(canEdit,indx,child,children)}return canEdit?(this.mask=bitmap,this.children=newChildren,this):IndexedNode(edit,bitmap,newChildren)},ArrayNode__modify=function ArrayNode__modify(edit,keyEq,shift,f,h,k,size){var count=this.size,children=this.children,frag=hashFragment(shift,h),child=children[frag],newChild=(child||empty)._modify(edit,keyEq,shift+5,f,h,k,size);if(child===newChild)return this;var canEdit=canEditNode(edit,this),newChildren=void 0;if(isEmptyNode(child)&&!isEmptyNode(newChild))++count,newChildren=arrayUpdate(canEdit,frag,newChild,children);else if(!isEmptyNode(child)&&isEmptyNode(newChild)){if(--count<=MIN_ARRAY_NODE)return function pack(edit,count,removed,elements){for(var children=new Array(count-1),g=0,bitmap=0,i=0,len=elements.length;i<len;++i)if(i!==removed){var elem=elements[i];elem&&!isEmptyNode(elem)&&(children[g++]=elem,bitmap|=1<<i)}return IndexedNode(edit,bitmap,children)}(edit,count,frag,children);newChildren=arrayUpdate(canEdit,frag,empty,children)}else newChildren=arrayUpdate(canEdit,frag,newChild,children);return canEdit?(this.size=count,this.children=newChildren,this):ArrayNode(edit,count,newChildren)};function Map(editable,edit,config,root,size){this._editable=editable,this._edit=edit,this._config=config,this._root=root,this._size=size}empty._modify=function(edit,keyEq,shift,f,h,k,size){var v=f();return v===nothing?empty:(++size.value,Leaf(edit,h,k,v))},Map.prototype.setTree=function(newRoot,newSize){return this._editable?(this._root=newRoot,this._size=newSize,this):newRoot===this._root?this:new Map(this._editable,this._edit,this._config,newRoot,newSize)};var tryGetHash=hamt.tryGetHash=function(alt,hash,key,map){for(var node=map._root,shift=0,keyEq=map._config.keyEq;;)switch(node.type){case 1:return keyEq(key,node.key)?node.value:alt;case 2:if(hash===node.hash)for(var children=node.children,i=0,len=children.length;i<len;++i){var child=children[i];if(keyEq(key,child.key))return child.value}return alt;case 3:var frag=hashFragment(shift,hash),bit=toBitmap(frag);if(node.mask&bit){node=node.children[fromBitmap(node.mask,bit)],shift+=5;break}return alt;case 4:if(node=node.children[hashFragment(shift,hash)]){shift+=5;break}return alt;default:return alt}};Map.prototype.tryGetHash=function(alt,hash,key){return tryGetHash(alt,hash,key,this)};var tryGet=hamt.tryGet=function(alt,key,map){return tryGetHash(alt,map._config.hash(key),key,map)};Map.prototype.tryGet=function(alt,key){return tryGet(alt,key,this)};var getHash=hamt.getHash=function(hash,key,map){return tryGetHash(void 0,hash,key,map)};Map.prototype.getHash=function(hash,key){return getHash(hash,key,this)};hamt.get=function(key,map){return tryGetHash(void 0,map._config.hash(key),key,map)};Map.prototype.get=function(key,alt){return tryGet(alt,key,this)};var hasHash=hamt.has=function(hash,key,map){return tryGetHash(nothing,hash,key,map)!==nothing};Map.prototype.hasHash=function(hash,key){return hasHash(hash,key,this)};var has=hamt.has=function(key,map){return hasHash(map._config.hash(key),key,map)};Map.prototype.has=function(key){return has(key,this)};var defKeyCompare=function defKeyCompare(x,y){return x===y};hamt.make=function(config){return new Map(0,0,{keyEq:config&&config.keyEq||defKeyCompare,hash:config&&config.hash||hash},empty,0)},hamt.empty=hamt.make();var isEmpty=hamt.isEmpty=function(map){return map&&!!isEmptyNode(map._root)};Map.prototype.isEmpty=function(){return isEmpty(this)};var modifyHash=hamt.modifyHash=function(f,hash,key,map){var size={value:map._size},newRoot=map._root._modify(map._editable?map._edit:NaN,map._config.keyEq,0,f,hash,key,size);return map.setTree(newRoot,size.value)};Map.prototype.modifyHash=function(hash,key,f){return modifyHash(f,hash,key,this)};var modify=hamt.modify=function(f,key,map){return modifyHash(f,map._config.hash(key),key,map)};Map.prototype.modify=function(key,f){return modify(f,key,this)};var setHash=hamt.setHash=function(hash,key,value,map){return modifyHash(constant(value),hash,key,map)};Map.prototype.setHash=function(hash,key,value){return setHash(hash,key,value,this)};var set=hamt.set=function(key,value,map){return setHash(map._config.hash(key),key,value,map)};Map.prototype.set=function(key,value){return set(key,value,this)};var del=constant(nothing),removeHash=hamt.removeHash=function(hash,key,map){return modifyHash(del,hash,key,map)};Map.prototype.removeHash=Map.prototype.deleteHash=function(hash,key){return removeHash(hash,key,this)};var remove=hamt.remove=function(key,map){return removeHash(map._config.hash(key),key,map)};Map.prototype.remove=Map.prototype.delete=function(key){return remove(key,this)};var beginMutation=hamt.beginMutation=function(map){return new Map(map._editable+1,map._edit+1,map._config,map._root,map._size)};Map.prototype.beginMutation=function(){return beginMutation(this)};var endMutation=hamt.endMutation=function(map){return map._editable=map._editable&&map._editable-1,map};Map.prototype.endMutation=function(){return endMutation(this)};var mutate=hamt.mutate=function(f,map){var transient=beginMutation(map);return f(transient),endMutation(transient)};Map.prototype.mutate=function(f){return mutate(f,this)};var appk=function appk(k){return k&&lazyVisitChildren(k[0],k[1],k[2],k[3],k[4])},lazyVisitChildren=function lazyVisitChildren(len,children,i,f,k){for(;i<len;){var child=children[i++];if(child&&!isEmptyNode(child))return lazyVisit(child,f,[len,children,i,f,k])}return appk(k)},lazyVisit=function lazyVisit(node,f,k){switch(node.type){case 1:return{value:f(node),rest:k};case 2:case 4:case 3:var children=node.children;return lazyVisitChildren(children.length,children,0,f,k);default:return appk(k)}},DONE={done:!0};function MapIterator(v){this.v=v}MapIterator.prototype.next=function(){if(!this.v)return DONE;var v0=this.v;return this.v=appk(v0.rest),v0},MapIterator.prototype[Symbol.iterator]=function(){return this};var visit=function visit(map,f){return new MapIterator(lazyVisit(map._root,f))},buildPairs=function buildPairs(x){return[x.key,x.value]},entries=hamt.entries=function(map){return visit(map,buildPairs)};Map.prototype.entries=Map.prototype[Symbol.iterator]=function(){return entries(this)};var buildKeys=function buildKeys(x){return x.key},keys=hamt.keys=function(map){return visit(map,buildKeys)};Map.prototype.keys=function(){return keys(this)};var buildValues=function buildValues(x){return x.value},values=hamt.values=Map.prototype.values=function(map){return visit(map,buildValues)};Map.prototype.values=function(){return values(this)};var fold=hamt.fold=function(f,z,m){var root=m._root;if(1===root.type)return f(z,root.value,root.key);for(var toVisit=[root.children],children=void 0;children=toVisit.pop();)for(var i=0,len=children.length;i<len;){var child=children[i++];child&&child.type&&(1===child.type?z=f(z,child.value,child.key):toVisit.push(child.children))}return z};Map.prototype.fold=function(f,z){return fold(f,z,this)};var forEach=hamt.forEach=function(f,map){return fold((function(_,value,key){return f(value,key,map)}),null,map)};Map.prototype.forEach=function(f){return forEach(f,this)};var count=hamt.count=function(map){return map._size};Map.prototype.count=function(){return count(this)},Object.defineProperty(Map.prototype,"size",{get:Map.prototype.count}),module.exports?module.exports=hamt:(void 0).hamt=hamt}));class BuiltInMap{constructor(existing){_defineProperty(this,"_map",void 0),this._map=new Map(null==existing?void 0:existing.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(k){return this._map.get(k)}has(k){return this._map.has(k)}set(k,v){return this._map.set(k,v),this}delete(k){return this._map.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._map)}}class HashArrayMappedTrieMap{constructor(existing){if(_defineProperty(this,"_hamt",hamt_1.empty.beginMutation()),existing instanceof HashArrayMappedTrieMap){const h=existing._hamt.endMutation();existing._hamt=h.beginMutation(),this._hamt=h.beginMutation()}else if(existing)for(const[k,v]of existing.entries())this._hamt.set(k,v)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(k){return this._hamt.get(k)}has(k){return this._hamt.has(k)}set(k,v){return this._hamt.set(k,v),this}delete(k){return this._hamt.delete(k),this}clone(){return persistentMap(this)}toMap(){return new Map(this._hamt)}}function persistentMap(existing){return Recoil_gkx("recoil_hamt_2020")?new HashArrayMappedTrieMap(existing):new BuiltInMap(existing)}var Recoil_PersistentMap_1=persistentMap,Recoil_PersistentMap$1=Object.freeze({__proto__:null,persistentMap:Recoil_PersistentMap_1});var Recoil_differenceSets=function differenceSets(set,...setsWithValuesToRemove){const ret=new Set;FIRST:for(const value of set){for(const otherSet of setsWithValuesToRemove)if(otherSet.has(value))continue FIRST;ret.add(value)}return ret};var Recoil_mapMap=function mapMap(map,callback){const result=new Map;return map.forEach(((value,key)=>{result.set(key,callback(value,key))})),result};function mergeDepsIntoGraph(key,newDeps,graph,olderGraph){const{nodeDeps:nodeDeps,nodeToNodeSubscriptions:nodeToNodeSubscriptions}=graph,oldDeps=nodeDeps.get(key);if(oldDeps&&olderGraph&&oldDeps!==olderGraph.nodeDeps.get(key))return;nodeDeps.set(key,newDeps);const addedDeps=null==oldDeps?newDeps:Recoil_differenceSets(newDeps,oldDeps);for(const dep of addedDeps){nodeToNodeSubscriptions.has(dep)||nodeToNodeSubscriptions.set(dep,new Set);Recoil_nullthrows(nodeToNodeSubscriptions.get(dep)).add(key)}if(oldDeps){const removedDeps=Recoil_differenceSets(oldDeps,newDeps);for(const dep of removedDeps){if(!nodeToNodeSubscriptions.has(dep))return;const existing=Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));existing.delete(key),0===existing.size&&nodeToNodeSubscriptions.delete(dep)}}}var Recoil_Graph={cloneGraph:function cloneGraph(graph){return{nodeDeps:Recoil_mapMap(graph.nodeDeps,(s=>new Set(s))),nodeToNodeSubscriptions:Recoil_mapMap(graph.nodeToNodeSubscriptions,(s=>new Set(s)))}},graph:function makeGraph(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},saveDepsToStore:function saveDepsToStore(key,deps,store,version){var _storeState$nextTree,_storeState$previousT,_storeState$previousT2,_storeState$previousT3;const storeState=store.getState();version!==storeState.currentTree.version&&version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&version!==(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT?void 0:_storeState$previousT.version)&&Recoil_recoverableViolation("Tried to save dependencies to a discarded tree");const graph=store.getGraph(version);if(mergeDepsIntoGraph(key,deps,graph),version===(null===(_storeState$previousT2=storeState.previousTree)||void 0===_storeState$previousT2?void 0:_storeState$previousT2.version)){mergeDepsIntoGraph(key,deps,store.getGraph(storeState.currentTree.version),graph)}if(version===(null===(_storeState$previousT3=storeState.previousTree)||void 0===_storeState$previousT3?void 0:_storeState$previousT3.version)||version===storeState.currentTree.version){var _storeState$nextTree2;const nextVersion=null===(_storeState$nextTree2=storeState.nextTree)||void 0===_storeState$nextTree2?void 0:_storeState$nextTree2.version;if(void 0!==nextVersion){mergeDepsIntoGraph(key,deps,store.getGraph(nextVersion),graph)}}}};let nextTreeStateVersion=0;let nextStoreID=0;let nextComponentID=0;var Recoil_Keys={getNextTreeStateVersion:()=>nextTreeStateVersion++,getNextStoreID:()=>nextStoreID++,getNextComponentID:()=>nextComponentID++};const{persistentMap:persistentMap$1}=Recoil_PersistentMap$1,{graph:graph}=Recoil_Graph,{getNextTreeStateVersion:getNextTreeStateVersion$1}=Recoil_Keys;function makeEmptyTreeState(){const version=getNextTreeStateVersion$1();return{version:version,stateID:version,transactionMetadata:{},dirtyAtoms:new Set,atomValues:persistentMap$1(),nonvalidatedAtoms:persistentMap$1()}}var Recoil_State={makeEmptyTreeState:makeEmptyTreeState,makeEmptyStoreState:function makeEmptyStoreState(){const currentTree=makeEmptyTreeState();return{currentTree:currentTree,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(currentTree.version,graph()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:getNextTreeStateVersion$1};class RetentionZone{}var Recoil_RetentionZone={RetentionZone:RetentionZone,retentionZone:function retentionZone(){return new RetentionZone}};var Recoil_CopyOnWrite={setByAddingToSet:function setByAddingToSet(set,v){const next=new Set(set);return next.add(v),next},setByDeletingFromSet:function setByDeletingFromSet(set,v){const next=new Set(set);return next.delete(v),next},mapBySettingInMap:function mapBySettingInMap(map,k,v){const next=new Map(map);return next.set(k,v),next},mapByUpdatingInMap:function mapByUpdatingInMap(map,k,updater){const next=new Map(map);return next.set(k,updater(next.get(k))),next},mapByDeletingFromMap:function mapByDeletingFromMap(map,k){const next=new Map(map);return next.delete(k),next},mapByDeletingMultipleFromMap:function mapByDeletingMultipleFromMap(map,ks){const next=new Map(map);return ks.forEach((k=>next.delete(k))),next}};var Recoil_filterIterable=function*filterIterable(iterable,predicate){let index=0;for(const value of iterable)predicate(value,index++)&&(yield value)};var Recoil_lazyProxy=function lazyProxy(base,factories){return new Proxy(base,{get:(target,prop)=>(!(prop in target)&&prop in factories&&(target[prop]=factories[prop]()),target[prop]),ownKeys:target=>Object.keys(target)})};const{getNode:getNode$1,getNodeMaybe:getNodeMaybe$1,recoilValuesForKeys:recoilValuesForKeys$1}=Recoil_Node,{RetentionZone:RetentionZone$1}=Recoil_RetentionZone,{setByAddingToSet:setByAddingToSet$1}=Recoil_CopyOnWrite,emptySet=Object.freeze(new Set);class ReadOnlyRecoilValueError extends Error{}function initializeNodeIfNewToStore(store,treeState,key,trigger){const storeState=store.getState();if(storeState.nodeCleanupFunctions.has(key))return;const node=getNode$1(key),retentionCleanup=function initializeRetentionForNode(store,nodeKey,retainedBy){if(!Recoil_gkx("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:nodesRetainedByZone}=store.getState().retention;function addToZone(zone){let set=nodesRetainedByZone.get(zone);set||nodesRetainedByZone.set(zone,set=new Set),set.add(nodeKey)}if(retainedBy instanceof RetentionZone$1)addToZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)addToZone(zone);return()=>{if(!Recoil_gkx("recoil_memory_managament_2020"))return;const{retention:retention}=store.getState();function deleteFromZone(zone){const set=retention.nodesRetainedByZone.get(zone);null==set||set.delete(nodeKey),set&&0===set.size&&retention.nodesRetainedByZone.delete(zone)}if(retainedBy instanceof RetentionZone$1)deleteFromZone(retainedBy);else if(Array.isArray(retainedBy))for(const zone of retainedBy)deleteFromZone(zone)}}(store,key,node.retainedBy),nodeCleanup=node.init(store,treeState,trigger);storeState.nodeCleanupFunctions.set(key,(()=>{nodeCleanup(),retentionCleanup()}))}function peekNodeLoadable(store,state,key){return getNode$1(key).peek(store,state)}function getDownstreamNodes(store,state,keys){const visitedNodes=new Set,visitingNodes=Array.from(keys),graph=store.getGraph(state.version);for(let key=visitingNodes.pop();key;key=visitingNodes.pop()){var _graph$nodeToNodeSubs;visitedNodes.add(key);const subscribedNodes=null!==(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(key))&&void 0!==_graph$nodeToNodeSubs?_graph$nodeToNodeSubs:emptySet;for(const downstreamNode of subscribedNodes)visitedNodes.has(downstreamNode)||visitingNodes.push(downstreamNode)}return visitedNodes}var Recoil_FunctionalCore={getNodeLoadable:function getNodeLoadable(store,state,key){return initializeNodeIfNewToStore(store,state,key,"get"),getNode$1(key).get(store,state)},peekNodeLoadable:peekNodeLoadable,setNodeValue:function setNodeValue(store,state,key,newValue){const node=getNode$1(key);if(null==node.set)throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);const set=node.set;return initializeNodeIfNewToStore(store,state,key,"set"),set(store,state,newValue)},initializeNode:function initializeNode(store,key,trigger){initializeNodeIfNewToStore(store,store.getState().currentTree,key,trigger)},cleanUpNode:function cleanUpNode(store,key){var _state$nodeCleanupFun;const state=store.getState();null===(_state$nodeCleanupFun=state.nodeCleanupFunctions.get(key))||void 0===_state$nodeCleanupFun||_state$nodeCleanupFun(),state.nodeCleanupFunctions.delete(key)},setUnvalidatedAtomValue_DEPRECATED:function setUnvalidatedAtomValue_DEPRECATED(state,key,newValue){var _node$invalidate;const node=getNodeMaybe$1(key);return null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),{...state,atomValues:state.atomValues.clone().delete(key),nonvalidatedAtoms:state.nonvalidatedAtoms.clone().set(key,newValue),dirtyAtoms:setByAddingToSet$1(state.dirtyAtoms,key)}},peekNodeInfo:function peekNodeInfo(store,state,key){const storeState=store.getState(),graph=store.getGraph(state.version),type=getNode$1(key).nodeType;return Recoil_lazyProxy({type:type},{loadable:()=>peekNodeLoadable(store,state,key),isActive:()=>storeState.knownAtoms.has(key)||storeState.knownSelectors.has(key),isSet:()=>"selector"!==type&&state.atomValues.has(key),isModified:()=>state.dirtyAtoms.has(key),deps:()=>{var _graph$nodeDeps$get;return recoilValuesForKeys$1(null!==(_graph$nodeDeps$get=graph.nodeDeps.get(key))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:[])},subscribers:()=>{var _storeState$nodeToCom,_storeState$nodeToCom2;return{nodes:recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store,state,new Set([key])),(nodeKey=>nodeKey!==key))),components:Recoil_mapIterable(null!==(_storeState$nodeToCom=null===(_storeState$nodeToCom2=storeState.nodeToComponentSubscriptions.get(key))||void 0===_storeState$nodeToCom2?void 0:_storeState$nodeToCom2.values())&&void 0!==_storeState$nodeToCom?_storeState$nodeToCom:[],(([name])=>({name:name})))}}})},getDownstreamNodes:getDownstreamNodes};let _invalidateMemoizedSnapshot=null;var Recoil_SnapshotCache={setInvalidateMemoizedSnapshot:function setInvalidateMemoizedSnapshot(invalidate){_invalidateMemoizedSnapshot=invalidate},invalidateMemoizedSnapshot:function invalidateMemoizedSnapshot(){var _invalidateMemoizedSn;null===(_invalidateMemoizedSn=_invalidateMemoizedSnapshot)||void 0===_invalidateMemoizedSn||_invalidateMemoizedSn()}};const{getDownstreamNodes:getDownstreamNodes$1,getNodeLoadable:getNodeLoadable$1,setNodeValue:setNodeValue$1}=Recoil_FunctionalCore,{getNextComponentID:getNextComponentID$1}=Recoil_Keys,{getNode:getNode$2,getNodeMaybe:getNodeMaybe$2}=Recoil_Node,{DefaultValue:DefaultValue$1}=Recoil_Node,{reactMode:reactMode$1}=Recoil_ReactMode,{AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,RecoilValueReadOnly:RecoilValueReadOnly$1,isRecoilValue:isRecoilValue$1}=Recoil_RecoilValue$1,{invalidateMemoizedSnapshot:invalidateMemoizedSnapshot$1}=Recoil_SnapshotCache;function applyAction(store,state,action){if("set"===action.type){const{recoilValue:recoilValue,valueOrUpdater:valueOrUpdater}=action,newValue=function valueFromValueOrUpdater(store,state,{key:key},valueOrUpdater){if("function"==typeof valueOrUpdater){const current=getNodeLoadable$1(store,state,key);if("loading"===current.state){const msg=`Tried to set atom or selector "${key}" using an updater function while the current state is pending, this is not currently supported.`;throw Recoil_recoverableViolation(msg),Recoil_err(msg)}if("hasError"===current.state)throw current.contents;return valueOrUpdater(current.contents)}return valueOrUpdater}(store,state,recoilValue,valueOrUpdater),writes=setNodeValue$1(store,state,recoilValue.key,newValue);for(const[key,loadable]of writes.entries())writeLoadableToTreeState(state,key,loadable)}else if("setLoadable"===action.type){const{recoilValue:{key:key},loadable:loadable}=action;writeLoadableToTreeState(state,key,loadable)}else if("markModified"===action.type){const{recoilValue:{key:key}}=action;state.dirtyAtoms.add(key)}else if("setUnvalidated"===action.type){var _node$invalidate;const{recoilValue:{key:key},unvalidatedValue:unvalidatedValue}=action,node=getNodeMaybe$2(key);null==node||null===(_node$invalidate=node.invalidate)||void 0===_node$invalidate||_node$invalidate.call(node,state),state.atomValues.delete(key),state.nonvalidatedAtoms.set(key,unvalidatedValue),state.dirtyAtoms.add(key)}else Recoil_recoverableViolation(`Unknown action ${action.type}`)}function writeLoadableToTreeState(state,key,loadable){"hasValue"===loadable.state&&loadable.contents instanceof DefaultValue$1?state.atomValues.delete(key):state.atomValues.set(key,loadable),state.dirtyAtoms.add(key),state.nonvalidatedAtoms.delete(key)}function applyActionsToStore(store,actions){store.replaceState((state=>{const newState=copyTreeState(state);for(const action of actions)applyAction(store,newState,action);return invalidateDownstreams(store,newState),invalidateMemoizedSnapshot$1(),newState}))}function queueOrPerformStateUpdate(store,action){if(batchStack.length){const actionsByStore=batchStack[batchStack.length-1];let actions=actionsByStore.get(store);actions||actionsByStore.set(store,actions=[]),actions.push(action)}else applyActionsToStore(store,[action])}const batchStack=[];function copyTreeState(state){return{...state,atomValues:state.atomValues.clone(),nonvalidatedAtoms:state.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(state.dirtyAtoms)}}function invalidateDownstreams(store,state){const downstreams=getDownstreamNodes$1(store,state,state.dirtyAtoms);for(const key of downstreams){var _getNodeMaybe,_getNodeMaybe$invalid;null===(_getNodeMaybe=getNodeMaybe$2(key))||void 0===_getNodeMaybe||null===(_getNodeMaybe$invalid=_getNodeMaybe.invalidate)||void 0===_getNodeMaybe$invalid||_getNodeMaybe$invalid.call(_getNodeMaybe,state)}}function setRecoilValue(store,recoilValue,valueOrUpdater){queueOrPerformStateUpdate(store,{type:"set",recoilValue:recoilValue,valueOrUpdater:valueOrUpdater})}var Recoil_RecoilValueInterface={RecoilValueReadOnly:RecoilValueReadOnly$1,AbstractRecoilValue:AbstractRecoilValue$1,RecoilState:RecoilState$1,getRecoilValueAsLoadable:function getRecoilValueAsLoadable(store,{key:key},treeState=store.getState().currentTree){var _storeState$nextTree,_storeState$previousT;const storeState=store.getState();treeState.version!==storeState.currentTree.version&&treeState.version!==(null===(_storeState$nextTree=storeState.nextTree)||void 0===_storeState$nextTree?void 0:_storeState$nextTree.version)&&treeState.version!==(null===(_storeState$previousT=storeState.previousTree)||void 0===_storeState$previousT?void 0:_storeState$previousT.version)&&Recoil_recoverableViolation("Tried to read from a discarded tree");const loadable=getNodeLoadable$1(store,treeState,key);return"loading"===loadable.state&&loadable.contents.catch((()=>{})),loadable},setRecoilValue:setRecoilValue,setRecoilValueLoadable:function setRecoilValueLoadable(store,recoilValue,loadable){if(loadable instanceof DefaultValue$1)return setRecoilValue(store,recoilValue,loadable);queueOrPerformStateUpdate(store,{type:"setLoadable",recoilValue:recoilValue,loadable:loadable})},markRecoilValueModified:function markRecoilValueModified(store,recoilValue){queueOrPerformStateUpdate(store,{type:"markModified",recoilValue:recoilValue})},setUnvalidatedRecoilValue:function setUnvalidatedRecoilValue(store,recoilValue,unvalidatedValue){queueOrPerformStateUpdate(store,{type:"setUnvalidated",recoilValue:recoilValue,unvalidatedValue:unvalidatedValue})},subscribeToRecoilValue:function subscribeToRecoilValue(store,{key:key},callback,componentDebugName=null){const subID=getNextComponentID$1(),storeState=store.getState();storeState.nodeToComponentSubscriptions.has(key)||storeState.nodeToComponentSubscriptions.set(key,new Map),Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID,[null!=componentDebugName?componentDebugName:"<not captured>",callback]);const mode=reactMode$1();if(mode.early&&("LEGACY"===mode.mode||"MUTABLE_SOURCE"===mode.mode)){const nextTree=store.getState().nextTree;nextTree&&nextTree.dirtyAtoms.has(key)&&callback(nextTree)}return{release:()=>{const releaseStoreState=store.getState(),subs=releaseStoreState.nodeToComponentSubscriptions.get(key);void 0!==subs&&subs.has(subID)?(subs.delete(subID),0===subs.size&&releaseStoreState.nodeToComponentSubscriptions.delete(key)):Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`)}}},isRecoilValue:isRecoilValue$1,applyAtomValueWrites:function applyAtomValueWrites(atomValues,writes){const result=atomValues.clone();return writes.forEach(((v,k)=>{"hasValue"===v.state&&v.contents instanceof DefaultValue$1?result.delete(k):result.set(k,v)})),result},batchStart:function batchStart(){const actionsByStore=new Map;return batchStack.push(actionsByStore),()=>{for(const[store,actions]of actionsByStore)applyActionsToStore(store,actions);batchStack.pop()!==actionsByStore&&Recoil_recoverableViolation("Incorrect order of batch popping")}},writeLoadableToTreeState:writeLoadableToTreeState,invalidateDownstreams:invalidateDownstreams,copyTreeState:copyTreeState,refreshRecoilValue:function refreshRecoilValue(store,recoilValue){var _node$clearCache;const{currentTree:currentTree}=store.getState(),node=getNode$2(recoilValue.key);null===(_node$clearCache=node.clearCache)||void 0===_node$clearCache||_node$clearCache.call(node,store,currentTree)}};var Recoil_someSet=function someSet(set,callback,context){const iterator=set.entries();let current=iterator.next();for(;!current.done;){const entry=current.value;if(callback.call(context,entry[1],entry[0],set))return!0;current=iterator.next()}return!1};const{cleanUpNode:cleanUpNode$1}=Recoil_FunctionalCore,{deleteNodeConfigIfPossible:deleteNodeConfigIfPossible$1,getNode:getNode$3}=Recoil_Node,{RetentionZone:RetentionZone$2}=Recoil_RetentionZone,emptySet$1=new Set;function releaseRetainablesNowOnCurrentTree(store,retainables){const storeState=store.getState(),treeState=storeState.currentTree;if(storeState.nextTree)return void Recoil_recoverableViolation("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const nodes=new Set;for(const r of retainables)if(r instanceof RetentionZone$2)for(const n of nodesRetainedByZone(storeState,r))nodes.add(n);else nodes.add(r);const releasableNodes=function findReleasableNodes(store,searchFromNodes){const storeState=store.getState(),treeState=storeState.currentTree,graph=store.getGraph(treeState.version),releasableNodes=new Set,nonReleasableNodes=new Set;return findReleasableNodesInner(searchFromNodes),releasableNodes;function findReleasableNodesInner(searchFromNodes){const releasableNodesFoundThisIteration=new Set,downstreams=function getDownstreamNodesInTopologicalOrder(store,treeState,nodes,doNotDescendInto1,doNotDescendInto2){const graph=store.getGraph(treeState.version),answer=[],visited=new Set;for(;nodes.size>0;)visit(Recoil_nullthrows(nodes.values().next().value));return answer;function visit(node){if(doNotDescendInto1.has(node)||doNotDescendInto2.has(node))return void nodes.delete(node);if(visited.has(node))return;const children=graph.nodeToNodeSubscriptions.get(node);if(children)for(const child of children)visit(child);visited.add(node),nodes.delete(node),answer.push(node)}}(store,treeState,searchFromNodes,releasableNodes,nonReleasableNodes);for(const node of downstreams){var _storeState$retention;if("recoilRoot"===getNode$3(node).retainedBy){nonReleasableNodes.add(node);continue}if((null!==(_storeState$retention=storeState.retention.referenceCounts.get(node))&&void 0!==_storeState$retention?_storeState$retention:0)>0){nonReleasableNodes.add(node);continue}if(zonesThatCouldRetainNode(node).some((z=>storeState.retention.referenceCounts.get(z)))){nonReleasableNodes.add(node);continue}const nodeChildren=graph.nodeToNodeSubscriptions.get(node);nodeChildren&&Recoil_someSet(nodeChildren,(child=>nonReleasableNodes.has(child)))?nonReleasableNodes.add(node):(releasableNodes.add(node),releasableNodesFoundThisIteration.add(node))}const parents=new Set;for(const node of releasableNodesFoundThisIteration)for(const parent of null!==(_graph$nodeDeps$get=graph.nodeDeps.get(node))&&void 0!==_graph$nodeDeps$get?_graph$nodeDeps$get:emptySet$1){var _graph$nodeDeps$get;releasableNodes.has(parent)||parents.add(parent)}parents.size&&findReleasableNodesInner(parents)}}(store,nodes);for(const node of releasableNodes)releaseNode(store,treeState,node)}function releaseNode(store,treeState,node){if(!Recoil_gkx("recoil_memory_managament_2020"))return;cleanUpNode$1(store,node);const storeState=store.getState();storeState.knownAtoms.delete(node),storeState.knownSelectors.delete(node),storeState.nodeTransactionSubscriptions.delete(node),storeState.retention.referenceCounts.delete(node);const zones=zonesThatCouldRetainNode(node);for(const zone of zones){var _storeState$retention2;null===(_storeState$retention2=storeState.retention.nodesRetainedByZone.get(zone))||void 0===_storeState$retention2||_storeState$retention2.delete(node)}treeState.atomValues.delete(node),treeState.dirtyAtoms.delete(node),treeState.nonvalidatedAtoms.delete(node);const graph=storeState.graphsByVersion.get(treeState.version);if(graph){const deps=graph.nodeDeps.get(node);if(void 0!==deps){graph.nodeDeps.delete(node);for(const dep of deps){var _graph$nodeToNodeSubs;null===(_graph$nodeToNodeSubs=graph.nodeToNodeSubscriptions.get(dep))||void 0===_graph$nodeToNodeSubs||_graph$nodeToNodeSubs.delete(node)}}graph.nodeToNodeSubscriptions.delete(node)}deleteNodeConfigIfPossible$1(node)}function nodesRetainedByZone(storeState,zone){var _storeState$retention3;return null!==(_storeState$retention3=storeState.retention.nodesRetainedByZone.get(zone))&&void 0!==_storeState$retention3?_storeState$retention3:emptySet$1}function zonesThatCouldRetainNode(node){const retainedBy=getNode$3(node).retainedBy;return void 0===retainedBy||"components"===retainedBy||"recoilRoot"===retainedBy?[]:retainedBy instanceof RetentionZone$2?[retainedBy]:retainedBy}function updateRetainCountToZero(store,retainable){if(!Recoil_gkx("recoil_memory_managament_2020"))return;store.getState().retention.referenceCounts.delete(retainable),function scheduleOrPerformPossibleReleaseOfRetainable(store,retainable){const state=store.getState();state.nextTree?state.retention.retainablesToCheckForRelease.add(retainable):releaseRetainablesNowOnCurrentTree(store,new Set([retainable]))}(store,retainable)}var Recoil_Retention={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function updateRetainCount(store,retainable,delta){var _map$get;if(!Recoil_gkx("recoil_memory_managament_2020"))return;const map=store.getState().retention.referenceCounts,newCount=(null!==(_map$get=map.get(retainable))&&void 0!==_map$get?_map$get:0)+delta;0===newCount?updateRetainCountToZero(store,retainable):map.set(retainable,newCount)},updateRetainCountToZero:updateRetainCountToZero,releaseScheduledRetainablesNow:function releaseScheduledRetainablesNow(store){if(!Recoil_gkx("recoil_memory_managament_2020"))return;const state=store.getState();releaseRetainablesNowOnCurrentTree(store,state.retention.retainablesToCheckForRelease),state.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function retainedByOptionWithDefault(r){return void 0===r?"recoilRoot":r}};const{unstable_batchedUpdates:unstable_batchedUpdates}=react_dom__WEBPACK_IMPORTED_MODULE_1__;var ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates};const{unstable_batchedUpdates:unstable_batchedUpdates$1}=ReactBatchedUpdates;var Recoil_ReactBatchedUpdates={unstable_batchedUpdates:unstable_batchedUpdates$1};const{batchStart:batchStart$1}=Recoil_RecoilValueInterface,{unstable_batchedUpdates:unstable_batchedUpdates$2}=Recoil_ReactBatchedUpdates;let batcher=unstable_batchedUpdates$2||(batchFn=>batchFn());var Recoil_Batching={getBatcher:()=>batcher,setBatcher:newBatcher=>{batcher=newBatcher},batchUpdates:callback=>{batcher((()=>{let batchEnd=()=>{};try{batchEnd=batchStart$1(),callback()}finally{batchEnd()}}))}};var Recoil_concatIterables=function*concatIterables(iters){for(const iter of iters)for(const val of iter)yield val};const isSSR="undefined"==typeof Window||"undefined"==typeof window,isReactNative="undefined"!=typeof navigator&&"ReactNative"===navigator.product;var Recoil_Environment={isSSR:isSSR,isReactNative:isReactNative,isWindow:value=>!isSSR&&(value===window||value instanceof Window)};var Recoil_Memoize={memoizeWithArgsHash:function memoizeWithArgsHash(fn,hashFunction){let cache;return(...args)=>{cache||(cache={});const key=hashFunction(...args);return Object.hasOwnProperty.call(cache,key)||(cache[key]=fn(...args)),cache[key]}},memoizeOneWithArgsHash:function memoizeOneWithArgsHash(fn,hashFunction){let lastKey,lastResult;return(...args)=>{const key=hashFunction(...args);return lastKey===key||(lastKey=key,lastResult=fn(...args)),lastResult}},memoizeOneWithArgsHashAndInvalidation:function memoizeOneWithArgsHashAndInvalidation(fn,hashFunction){let lastKey,lastResult;return[(...args)=>{const key=hashFunction(...args);return lastKey===key||(lastKey=key,lastResult=fn(...args)),lastResult},()=>{lastKey=null}]}};const{batchUpdates:batchUpdates$1}=Recoil_Batching,{initializeNode:initializeNode$1,peekNodeInfo:peekNodeInfo$1}=Recoil_FunctionalCore,{graph:graph$1}=Recoil_Graph,{getNextStoreID:getNextStoreID$1}=Recoil_Keys,{DEFAULT_VALUE:DEFAULT_VALUE$1,recoilValues:recoilValues$1,recoilValuesForKeys:recoilValuesForKeys$2}=Recoil_Node,{AbstractRecoilValue:AbstractRecoilValue$2,getRecoilValueAsLoadable:getRecoilValueAsLoadable$1,setRecoilValue:setRecoilValue$1,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$1}=Recoil_RecoilValueInterface,{updateRetainCount:updateRetainCount$1}=Recoil_Retention,{setInvalidateMemoizedSnapshot:setInvalidateMemoizedSnapshot$1}=Recoil_SnapshotCache,{getNextTreeStateVersion:getNextTreeStateVersion$2,makeEmptyStoreState:makeEmptyStoreState$1}=Recoil_State,{isSSR:isSSR$1}=Recoil_Environment,{memoizeOneWithArgsHashAndInvalidation:memoizeOneWithArgsHashAndInvalidation$1}=Recoil_Memoize;class Snapshot{constructor(storeState,parentStoreID){_defineProperty(this,"_store",void 0),_defineProperty(this,"_refCount",1),_defineProperty(this,"getLoadable",(recoilValue=>(this.checkRefCount_INTERNAL(),getRecoilValueAsLoadable$1(this._store,recoilValue)))),_defineProperty(this,"getPromise",(recoilValue=>(this.checkRefCount_INTERNAL(),this.getLoadable(recoilValue).toPromise()))),_defineProperty(this,"getNodes_UNSTABLE",(opt=>{if(this.checkRefCount_INTERNAL(),!0===(null==opt?void 0:opt.isModified)){if(!1===(null==opt?void 0:opt.isInitialized))return[];const state=this._store.getState().currentTree;return recoilValuesForKeys$2(state.dirtyAtoms)}const knownAtoms=this._store.getState().knownAtoms,knownSelectors=this._store.getState().knownSelectors;return null==(null==opt?void 0:opt.isInitialized)?recoilValues$1.values():!0===opt.isInitialized?recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms,knownSelectors])):Recoil_filterIterable(recoilValues$1.values(),(({key:key})=>!knownAtoms.has(key)&&!knownSelectors.has(key)))})),_defineProperty(this,"getInfo_UNSTABLE",(({key:key})=>(this.checkRefCount_INTERNAL(),peekNodeInfo$1(this._store,this._store.getState().currentTree,key)))),_defineProperty(this,"map",(mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this,batchUpdates$1);return mapper(mutableSnapshot),mutableSnapshot})),_defineProperty(this,"asyncMap",(async mapper=>{this.checkRefCount_INTERNAL();const mutableSnapshot=new MutableSnapshot(this,batchUpdates$1);return mutableSnapshot.retain(),await mapper(mutableSnapshot),mutableSnapshot.autoRelease_INTERNAL(),mutableSnapshot})),this._store={storeID:getNextStoreID$1(),parentStoreID:parentStoreID,getState:()=>storeState,replaceState:replacer=>{storeState.currentTree=replacer(storeState.currentTree)},getGraph:version=>{const graphs=storeState.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$1();return graphs.set(version,newGraph),newGraph},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw Recoil_err("Cannot subscribe to Snapshots")}};for(const nodeKey of this._store.getState().knownAtoms)initializeNode$1(this._store,nodeKey,"get"),updateRetainCount$1(this._store,nodeKey,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&Recoil_recoverableViolation("Attempt to retain() Snapshot that was already released."),this._refCount++;let released=!1;return()=>{released||(released=!0,this._release())}}autoRelease_INTERNAL(){isSSR$1||window.setTimeout((()=>this._release()),10)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach((cleanup=>cleanup())),this._store.getState().nodeCleanupFunctions.clear(),!Recoil_gkx("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){Recoil_gkx("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}getStoreID(){return this.checkRefCount_INTERNAL(),this._store.storeID}}function cloneStoreState(store,treeState,bumpVersion=!1){const storeState=store.getState(),version=bumpVersion?getNextTreeStateVersion$2():treeState.version;return{currentTree:{version:bumpVersion?version:treeState.version,stateID:bumpVersion?version:treeState.stateID,transactionMetadata:{...treeState.transactionMetadata},dirtyAtoms:new Set(treeState.dirtyAtoms),atomValues:treeState.atomValues.clone(),nonvalidatedAtoms:treeState.nonvalidatedAtoms.clone()},commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(storeState.knownAtoms),knownSelectors:new Set(storeState.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(version,store.getGraph(treeState.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(),(([key])=>[key,()=>{}])))}}const[memoizedCloneSnapshot,invalidateMemoizedSnapshot$2]=memoizeOneWithArgsHashAndInvalidation$1(((store,version)=>{var _storeState$nextTree;const storeState=store.getState(),treeState="latest"===version?null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree:Recoil_nullthrows(storeState.previousTree);return new Snapshot(cloneStoreState(store,treeState),store.storeID)}),((store,version)=>{var _store$getState$nextT,_store$getState$previ;return String(version)+String(store.storeID)+String(null===(_store$getState$nextT=store.getState().nextTree)||void 0===_store$getState$nextT?void 0:_store$getState$nextT.version)+String(store.getState().currentTree.version)+String(null===(_store$getState$previ=store.getState().previousTree)||void 0===_store$getState$previ?void 0:_store$getState$previ.version)}));setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);class MutableSnapshot extends Snapshot{constructor(snapshot,batch){super(cloneStoreState(snapshot.getStore_INTERNAL(),snapshot.getStore_INTERNAL().getState().currentTree,!0),snapshot.getStoreID()),_defineProperty(this,"_batch",void 0),_defineProperty(this,"set",((recoilState,newValueOrUpdater)=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();this._batch((()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,newValueOrUpdater)}))})),_defineProperty(this,"reset",(recoilState=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();this._batch((()=>{updateRetainCount$1(store,recoilState.key,1),setRecoilValue$1(this.getStore_INTERNAL(),recoilState,DEFAULT_VALUE$1)}))})),_defineProperty(this,"setUnvalidatedAtomValues_DEPRECATED",(values=>{this.checkRefCount_INTERNAL();const store=this.getStore_INTERNAL();batchUpdates$1((()=>{for(const[k,v]of values.entries())updateRetainCount$1(store,k,1),setUnvalidatedRecoilValue$1(store,new AbstractRecoilValue$2(k),v)}))})),this._batch=batch}}var Recoil_Snapshot={Snapshot:Snapshot,MutableSnapshot:MutableSnapshot,freshSnapshot:function freshSnapshot(initializeState){const snapshot=new Snapshot(makeEmptyStoreState$1());return null!=initializeState?snapshot.map(initializeState):snapshot},cloneSnapshot:function cloneSnapshot(store,version="latest"){const snapshot=memoizedCloneSnapshot(store,version);return snapshot.isRetained()?snapshot:(invalidateMemoizedSnapshot$2(),memoizedCloneSnapshot(store,version))}},Recoil_Snapshot_1=Recoil_Snapshot.Snapshot,Recoil_Snapshot_2=Recoil_Snapshot.MutableSnapshot,Recoil_Snapshot_3=Recoil_Snapshot.freshSnapshot,Recoil_Snapshot_4=Recoil_Snapshot.cloneSnapshot,Recoil_Snapshot$1=Object.freeze({__proto__:null,Snapshot:Recoil_Snapshot_1,MutableSnapshot:Recoil_Snapshot_2,freshSnapshot:Recoil_Snapshot_3,cloneSnapshot:Recoil_Snapshot_4});var Recoil_unionSets=function unionSets(...sets){const result=new Set;for(const set of sets)for(const value of set)result.add(value);return result};const{useRef:useRef}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRefInitOnce=function useRefInitOnce(initialValue){const ref=useRef(initialValue);return ref.current===initialValue&&"function"==typeof initialValue&&(ref.current=initialValue()),ref};const{getNextTreeStateVersion:getNextTreeStateVersion$3,makeEmptyStoreState:makeEmptyStoreState$2}=Recoil_State,{cleanUpNode:cleanUpNode$2,getDownstreamNodes:getDownstreamNodes$2,initializeNode:initializeNode$2,setNodeValue:setNodeValue$2,setUnvalidatedAtomValue_DEPRECATED:setUnvalidatedAtomValue_DEPRECATED$1}=Recoil_FunctionalCore,{graph:graph$2}=Recoil_Graph,{cloneGraph:cloneGraph$1}=Recoil_Graph,{getNextStoreID:getNextStoreID$2}=Recoil_Keys,{createMutableSource:createMutableSource$1,reactMode:reactMode$2}=Recoil_ReactMode,{applyAtomValueWrites:applyAtomValueWrites$1}=Recoil_RecoilValueInterface,{releaseScheduledRetainablesNow:releaseScheduledRetainablesNow$1}=Recoil_Retention,{freshSnapshot:freshSnapshot$1}=Recoil_Snapshot$1,{useCallback:useCallback,useContext:useContext,useEffect:useEffect,useMemo:useMemo,useRef:useRef$1,useState:useState}=react__WEBPACK_IMPORTED_MODULE_0__;function notInAContext(){throw Recoil_err("This component must be used inside a <RecoilRoot> component.")}const defaultStore=Object.freeze({storeID:getNextStoreID$2(),getState:notInAContext,replaceState:notInAContext,getGraph:notInAContext,subscribeToTransactions:notInAContext,addTransactionMetadata:notInAContext});let stateReplacerIsBeingExecuted=!1;function startNextTreeIfNeeded(store){if(stateReplacerIsBeingExecuted)throw Recoil_err("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const storeState=store.getState();if(null===storeState.nextTree){Recoil_gkx("recoil_memory_managament_2020")&&Recoil_gkx("recoil_release_on_cascading_update_killswitch_2021")&&storeState.commitDepth>0&&releaseScheduledRetainablesNow$1(store);const version=storeState.currentTree.version,nextVersion=getNextTreeStateVersion$3();storeState.nextTree={...storeState.currentTree,version:nextVersion,stateID:nextVersion,dirtyAtoms:new Set,transactionMetadata:{}},storeState.graphsByVersion.set(nextVersion,cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))))}}const AppContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext({current:defaultStore}),useStoreRef=()=>useContext(AppContext),MutableSourceContext=react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);function notifyComponents(store,storeState,treeState){const dependentNodes=getDownstreamNodes$2(store,treeState,treeState.dirtyAtoms);for(const key of dependentNodes){const comps=storeState.nodeToComponentSubscriptions.get(key);if(comps)for(const[_subID,[_debugName,callback]]of comps)callback(treeState)}}function sendEndOfBatchNotifications(store){const storeState=store.getState(),treeState=storeState.currentTree,dirtyAtoms=treeState.dirtyAtoms;if(dirtyAtoms.size){for(const[key,subscriptions]of storeState.nodeTransactionSubscriptions)if(dirtyAtoms.has(key))for(const[_,subscription]of subscriptions)subscription(store);for(const[_,subscription]of storeState.transactionSubscriptions)subscription(store);(!reactMode$2().early||storeState.suspendedComponentResolvers.size>0)&&(notifyComponents(store,storeState,treeState),storeState.suspendedComponentResolvers.forEach((cb=>cb())),storeState.suspendedComponentResolvers.clear())}storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb=>cb(treeState))),storeState.queuedComponentCallbacks_DEPRECATED.splice(0,storeState.queuedComponentCallbacks_DEPRECATED.length)}function Batcher({setNotifyBatcherOfChange:setNotifyBatcherOfChange}){const storeRef=useStoreRef(),[,setState]=useState([]);return setNotifyBatcherOfChange((()=>setState({}))),useEffect((()=>(setNotifyBatcherOfChange((()=>setState({}))),()=>{setNotifyBatcherOfChange((()=>{}))})),[setNotifyBatcherOfChange]),useEffect((()=>{Recoil_Queue.enqueueExecution("Batcher",(()=>{!function endBatch(store){const storeState=store.getState();storeState.commitDepth++;try{const{nextTree:nextTree}=storeState;if(null==nextTree)return;storeState.previousTree=storeState.currentTree,storeState.currentTree=nextTree,storeState.nextTree=null,sendEndOfBatchNotifications(store),null!=storeState.previousTree?storeState.graphsByVersion.delete(storeState.previousTree.version):Recoil_recoverableViolation("Ended batch with no previous state, which is unexpected","recoil"),storeState.previousTree=null,Recoil_gkx("recoil_memory_managament_2020")&&null==nextTree&&releaseScheduledRetainablesNow$1(store)}finally{storeState.commitDepth--}}(storeRef.current)}))})),null}let nextID=0;function RecoilRoot_INTERNAL({initializeState_DEPRECATED:initializeState_DEPRECATED,initializeState:initializeState,store_INTERNAL:storeProp,children:children}){let storeStateRef;const getGraph=version=>{const graphs=storeStateRef.current.graphsByVersion;if(graphs.has(version))return Recoil_nullthrows(graphs.get(version));const newGraph=graph$2();return graphs.set(version,newGraph),newGraph},subscribeToTransactions=(callback,key)=>{if(null==key){const{transactionSubscriptions:transactionSubscriptions}=storeRef.current.getState(),id=nextID++;return transactionSubscriptions.set(id,callback),{release:()=>{transactionSubscriptions.delete(id)}}}{const{nodeTransactionSubscriptions:nodeTransactionSubscriptions}=storeRef.current.getState();nodeTransactionSubscriptions.has(key)||nodeTransactionSubscriptions.set(key,new Map);const id=nextID++;return Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id,callback),{release:()=>{const subs=nodeTransactionSubscriptions.get(key);subs&&(subs.delete(id),0===subs.size&&nodeTransactionSubscriptions.delete(key))}}}},addTransactionMetadata=metadata=>{startNextTreeIfNeeded(storeRef.current);for(const k of Object.keys(metadata))Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k]=metadata[k]},replaceState=replacer=>{startNextTreeIfNeeded(storeRef.current);const nextTree=Recoil_nullthrows(storeStateRef.current.nextTree);let replaced;try{stateReplacerIsBeingExecuted=!0,replaced=replacer(nextTree)}finally{stateReplacerIsBeingExecuted=!1}replaced!==nextTree&&(storeStateRef.current.nextTree=replaced,reactMode$2().early&&notifyComponents(storeRef.current,storeStateRef.current,replaced),Recoil_nullthrows(notifyBatcherOfChange.current)())},notifyBatcherOfChange=useRef$1(null),setNotifyBatcherOfChange=useCallback((x=>{notifyBatcherOfChange.current=x}),[notifyBatcherOfChange]),storeRef=Recoil_useRefInitOnce((()=>null!=storeProp?storeProp:{storeID:getNextStoreID$2(),getState:()=>storeStateRef.current,replaceState:replaceState,getGraph:getGraph,subscribeToTransactions:subscribeToTransactions,addTransactionMetadata:addTransactionMetadata}));null!=storeProp&&(storeRef.current=storeProp),storeStateRef=Recoil_useRefInitOnce((()=>null!=initializeState_DEPRECATED?function initialStoreState_DEPRECATED(store,initializeState){const initial=makeEmptyStoreState$2();return initializeState({set:(atom,value)=>{const state=initial.currentTree,writes=setNodeValue$2(store,state,atom.key,value),writtenNodes=new Set(writes.keys()),nonvalidatedAtoms=state.nonvalidatedAtoms.clone();for(const n of writtenNodes)nonvalidatedAtoms.delete(n);initial.currentTree={...state,dirtyAtoms:Recoil_unionSets(state.dirtyAtoms,writtenNodes),atomValues:applyAtomValueWrites$1(state.atomValues,writes),nonvalidatedAtoms:nonvalidatedAtoms}},setUnvalidatedAtomValues:atomValues=>{atomValues.forEach(((v,k)=>{initial.currentTree=setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree,k,v)}))}}),initial}(storeRef.current,initializeState_DEPRECATED):null!=initializeState?function initialStoreState(initializeState){const snapshot=freshSnapshot$1(initializeState),storeState=snapshot.getStore_INTERNAL().getState();return snapshot.retain(),storeState.nodeCleanupFunctions.forEach((cleanup=>cleanup())),storeState.nodeCleanupFunctions.clear(),storeState}(initializeState):makeEmptyStoreState$2()));const mutableSource=useMemo((()=>null==createMutableSource$1?void 0:createMutableSource$1(storeStateRef,(()=>storeStateRef.current.currentTree.version))),[storeStateRef]);return useEffect((()=>{const store=storeRef.current;for(const atomKey of new Set(store.getState().knownAtoms))initializeNode$2(store,atomKey,"get");return()=>{for(const atomKey of store.getState().knownAtoms)cleanUpNode$2(store,atomKey)}}),[storeRef]),react__WEBPACK_IMPORTED_MODULE_0__.createElement(AppContext.Provider,{value:storeRef},react__WEBPACK_IMPORTED_MODULE_0__.createElement(MutableSourceContext.Provider,{value:mutableSource},react__WEBPACK_IMPORTED_MODULE_0__.createElement(Batcher,{setNotifyBatcherOfChange:setNotifyBatcherOfChange}),children))}var Recoil_RecoilRoot={RecoilRoot:function RecoilRoot(props){const{override:override,...propsExceptOverride}=props,ancestorStoreRef=useStoreRef();return!1===override&&ancestorStoreRef.current!==defaultStore?props.children:react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecoilRoot_INTERNAL,propsExceptOverride)},useStoreRef:useStoreRef,useRecoilMutableSource:function useRecoilMutableSource(){const mutableSource=useContext(MutableSourceContext);return null==mutableSource&&Recoil_expectationViolation("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),mutableSource},useRecoilStoreID:function useRecoilStoreID(){return useStoreRef().current.storeID},notifyComponents_FOR_TESTING:notifyComponents,sendEndOfBatchNotifications_FOR_TESTING:sendEndOfBatchNotifications};var Recoil_shallowArrayEqual=function shallowArrayEqual(a,b){if(a===b)return!0;if(a.length!==b.length)return!1;for(let i=0,l=a.length;i<l;i++)if(a[i]!==b[i])return!1;return!0};const{useEffect:useEffect$1,useRef:useRef$2}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_usePrevious=function usePrevious(value){const ref=useRef$2();return useEffect$1((()=>{ref.current=value})),ref.current};const{useStoreRef:useStoreRef$1}=Recoil_RecoilRoot,{SUSPENSE_TIMEOUT_MS:SUSPENSE_TIMEOUT_MS$1}=Recoil_Retention,{updateRetainCount:updateRetainCount$2}=Recoil_Retention,{RetentionZone:RetentionZone$3}=Recoil_RetentionZone,{useEffect:useEffect$2,useRef:useRef$3}=react__WEBPACK_IMPORTED_MODULE_0__,{isSSR:isSSR$2}=Recoil_Environment;var Recoil_useRetain=function useRetain(toRetain){if(Recoil_gkx("recoil_memory_managament_2020"))return function useRetain_ACTUAL(toRetain){const array=Array.isArray(toRetain)?toRetain:[toRetain],retainables=array.map((a=>a instanceof RetentionZone$3?a:a.key)),storeRef=useStoreRef$1();useEffect$2((()=>{if(!Recoil_gkx("recoil_memory_managament_2020"))return;const store=storeRef.current;if(timeoutID.current&&!isSSR$2)window.clearTimeout(timeoutID.current),timeoutID.current=null;else for(const r of retainables)updateRetainCount$2(store,r,1);return()=>{for(const r of retainables)updateRetainCount$2(store,r,-1)}}),[storeRef,...retainables]);const timeoutID=useRef$3(),previousRetainables=Recoil_usePrevious(retainables);if(!(isSSR$2||void 0!==previousRetainables&&Recoil_shallowArrayEqual(previousRetainables,retainables))){const store=storeRef.current;for(const r of retainables)updateRetainCount$2(store,r,1);if(previousRetainables)for(const r of previousRetainables)updateRetainCount$2(store,r,-1);timeoutID.current&&window.clearTimeout(timeoutID.current),timeoutID.current=window.setTimeout((()=>{timeoutID.current=null;for(const r of retainables)updateRetainCount$2(store,r,-1)}),SUSPENSE_TIMEOUT_MS$1)}}(toRetain)};var Recoil_useComponentName=function useComponentName(){return"<component name not available>"};const{batchUpdates:batchUpdates$2}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$2}=Recoil_Node,{currentRendererSupportsUseSyncExternalStore:currentRendererSupportsUseSyncExternalStore$1,reactMode:reactMode$3,useMutableSource:useMutableSource$1,useSyncExternalStore:useSyncExternalStore$1}=Recoil_ReactMode,{useRecoilMutableSource:useRecoilMutableSource$1,useStoreRef:useStoreRef$2}=Recoil_RecoilRoot,{isRecoilValue:isRecoilValue$2}=Recoil_RecoilValue$1,{AbstractRecoilValue:AbstractRecoilValue$3,getRecoilValueAsLoadable:getRecoilValueAsLoadable$2,setRecoilValue:setRecoilValue$2,setUnvalidatedRecoilValue:setUnvalidatedRecoilValue$2,subscribeToRecoilValue:subscribeToRecoilValue$1}=Recoil_RecoilValueInterface,{useCallback:useCallback$1,useEffect:useEffect$3,useMemo:useMemo$1,useRef:useRef$4,useState:useState$1}=react__WEBPACK_IMPORTED_MODULE_0__,{setByAddingToSet:setByAddingToSet$2}=Recoil_CopyOnWrite,{isSSR:isSSR$3}=Recoil_Environment;function handleLoadable(loadable,recoilValue,storeRef){if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){throw new Promise((resolve=>{const suspendedComponentResolvers=storeRef.current.getState().suspendedComponentResolvers;suspendedComponentResolvers.add(resolve),isSSR$3&&Recoil_isPromise(loadable.contents)&&loadable.contents.finally((()=>{suspendedComponentResolvers.delete(resolve)}))}))}throw"hasError"===loadable.state?loadable.contents:Recoil_err(`Invalid value of loadable atom "${recoilValue.key}"`)}function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue){const storeRef=useStoreRef$2(),componentName=Recoil_useComponentName(),getSnapshot=useCallback$1((()=>{var _storeState$nextTree2;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree2=storeState.nextTree)&&void 0!==_storeState$nextTree2?_storeState$nextTree2:storeState.currentTree;return{loadable:getRecoilValueAsLoadable$2(store,recoilValue,treeState),key:recoilValue.key}}),[storeRef,recoilValue]),memoizePreviousSnapshot=useCallback$1((getState=>{let prevState;return()=>{var _prevState,_prevState2;const nextState=getState();return null!==(_prevState=prevState)&&void 0!==_prevState&&_prevState.loadable.is(nextState.loadable)&&(null===(_prevState2=prevState)||void 0===_prevState2?void 0:_prevState2.key)===nextState.key?prevState:(prevState=nextState,nextState)}}),[]),getMemoizedSnapshot=useMemo$1((()=>memoizePreviousSnapshot(getSnapshot)),[getSnapshot,memoizePreviousSnapshot]),subscribe=useCallback$1((notify=>{const store=storeRef.current;return subscribeToRecoilValue$1(store,recoilValue,notify,componentName).release}),[storeRef,recoilValue,componentName]);return useSyncExternalStore$1(subscribe,getMemoizedSnapshot,getMemoizedSnapshot).loadable}function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue){const storeRef=useStoreRef$2(),getLoadable=useCallback$1((()=>{var _storeState$nextTree3;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree3=storeState.nextTree)&&void 0!==_storeState$nextTree3?_storeState$nextTree3:storeState.currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)}),[storeRef,recoilValue]),getLoadableWithTesting=useCallback$1((()=>getLoadable()),[getLoadable]),componentName=Recoil_useComponentName(),subscribe=useCallback$1(((_storeState,notify)=>{const store=storeRef.current;return subscribeToRecoilValue$1(store,recoilValue,(()=>{if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return notify();const newLoadable=getLoadable();prevLoadableRef.current.is(newLoadable)||notify(),prevLoadableRef.current=newLoadable}),componentName).release}),[storeRef,recoilValue,componentName,getLoadable]),source=useRecoilMutableSource$1();if(null==source)throw Recoil_err("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const loadable=useMutableSource$1(source,getLoadableWithTesting,subscribe),prevLoadableRef=useRef$4(loadable);return useEffect$3((()=>{prevLoadableRef.current=loadable})),loadable}function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue){const storeRef=useStoreRef$2(),componentName=Recoil_useComponentName(),getLoadable=useCallback$1((()=>{var _storeState$nextTree4;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree4=storeState.nextTree)&&void 0!==_storeState$nextTree4?_storeState$nextTree4:storeState.currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)}),[storeRef,recoilValue]),getState=useCallback$1((()=>({loadable:getLoadable(),key:recoilValue.key})),[getLoadable,recoilValue.key]),updateState=useCallback$1((prevState=>{const nextState=getState();return prevState.loadable.is(nextState.loadable)&&prevState.key===nextState.key?prevState:nextState}),[getState]);useEffect$3((()=>{const subscription=subscribeToRecoilValue$1(storeRef.current,recoilValue,(_state=>{setState(updateState)}),componentName);return setState(updateState),subscription.release}),[componentName,recoilValue,storeRef,updateState]);const[state,setState]=useState$1(getState);return state.key!==recoilValue.key?getState().loadable:state.loadable}function useRecoilValueLoadable_LEGACY(recoilValue){const storeRef=useStoreRef$2(),[,forceUpdate]=useState$1([]),componentName=Recoil_useComponentName(),getLoadable=useCallback$1((()=>{var _storeState$nextTree5;const store=storeRef.current,storeState=store.getState(),treeState=reactMode$3().early&&null!==(_storeState$nextTree5=storeState.nextTree)&&void 0!==_storeState$nextTree5?_storeState$nextTree5:storeState.currentTree;return getRecoilValueAsLoadable$2(store,recoilValue,treeState)}),[storeRef,recoilValue]),loadable=getLoadable(),prevLoadableRef=useRef$4(loadable);return useEffect$3((()=>{prevLoadableRef.current=loadable})),useEffect$3((()=>{const store=storeRef.current,storeState=store.getState(),subscription=subscribeToRecoilValue$1(store,recoilValue,(_state=>{var _prevLoadableRef$curr;if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getLoadable();null!==(_prevLoadableRef$curr=prevLoadableRef.current)&&void 0!==_prevLoadableRef$curr&&_prevLoadableRef$curr.is(newLoadable)||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable}),componentName);if(storeState.nextTree)store.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{prevLoadableRef.current=null,forceUpdate([])}));else{var _prevLoadableRef$curr2;if(!Recoil_gkx("recoil_suppress_rerender_in_callback"))return forceUpdate([]);const newLoadable=getLoadable();null!==(_prevLoadableRef$curr2=prevLoadableRef.current)&&void 0!==_prevLoadableRef$curr2&&_prevLoadableRef$curr2.is(newLoadable)||forceUpdate(newLoadable),prevLoadableRef.current=newLoadable}return subscription.release}),[componentName,getLoadable,recoilValue,storeRef]),loadable}function useRecoilValueLoadable(recoilValue){return Recoil_gkx("recoil_memory_managament_2020")&&Recoil_useRetain(recoilValue),{TRANSITION_SUPPORT:useRecoilValueLoadable_TRANSITION_SUPPORT,SYNC_EXTERNAL_STORE:currentRendererSupportsUseSyncExternalStore$1()?useRecoilValueLoadable_SYNC_EXTERNAL_STORE:useRecoilValueLoadable_TRANSITION_SUPPORT,MUTABLE_SOURCE:useRecoilValueLoadable_MUTABLE_SOURCE,LEGACY:useRecoilValueLoadable_LEGACY}[reactMode$3().mode](recoilValue)}function useRecoilValue(recoilValue){const storeRef=useStoreRef$2();return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}function useSetRecoilState(recoilState){const storeRef=useStoreRef$2();return useCallback$1((newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}),[storeRef,recoilState])}function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue){return Recoil_gkx("recoil_memory_managament_2020")&&Recoil_useRetain(recoilValue),useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue)}function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue){const storeRef=useStoreRef$2();return handleLoadable(useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue),recoilValue,storeRef)}var Recoil_Hooks={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function useRecoilInterface_DEPRECATED(){const componentName=Recoil_useComponentName(),storeRef=useStoreRef$2(),[,forceUpdate]=useState$1([]),recoilValuesUsed=useRef$4(new Set);recoilValuesUsed.current=new Set;const previousSubscriptions=useRef$4(new Set),subscriptions=useRef$4(new Map),unsubscribeFrom=useCallback$1((key=>{const sub=subscriptions.current.get(key);sub&&(sub.release(),subscriptions.current.delete(key))}),[subscriptions]),updateState=useCallback$1(((_state,key)=>{subscriptions.current.has(key)&&forceUpdate([])}),[]);return useEffect$3((()=>{const store=storeRef.current;Recoil_differenceSets(recoilValuesUsed.current,previousSubscriptions.current).forEach((key=>{if(subscriptions.current.has(key))return void Recoil_expectationViolation(`Double subscription to RecoilValue "${key}"`);const sub=subscribeToRecoilValue$1(store,new AbstractRecoilValue$3(key),(state=>updateState(state,key)),componentName);subscriptions.current.set(key,sub);store.getState().nextTree?store.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{updateState(store.getState(),key)})):updateState(store.getState(),key)})),Recoil_differenceSets(previousSubscriptions.current,recoilValuesUsed.current).forEach((key=>{unsubscribeFrom(key)})),previousSubscriptions.current=recoilValuesUsed.current})),useEffect$3((()=>{const currentSubscriptions=subscriptions.current;return Recoil_differenceSets(recoilValuesUsed.current,new Set(currentSubscriptions.keys())).forEach((key=>{const sub=subscribeToRecoilValue$1(storeRef.current,new AbstractRecoilValue$3(key),(state=>updateState(state,key)),componentName);currentSubscriptions.set(key,sub)})),()=>currentSubscriptions.forEach(((_,key)=>unsubscribeFrom(key)))}),[componentName,storeRef,unsubscribeFrom,updateState]),useMemo$1((()=>{function useSetRecoilState(recoilState){return newValueOrUpdater=>{setRecoilValue$2(storeRef.current,recoilState,newValueOrUpdater)}}function useRecoilValueLoadable(recoilValue){var _storeState$nextTree;recoilValuesUsed.current.has(recoilValue.key)||(recoilValuesUsed.current=setByAddingToSet$2(recoilValuesUsed.current,recoilValue.key));const storeState=storeRef.current.getState();return getRecoilValueAsLoadable$2(storeRef.current,recoilValue,reactMode$3().early&&null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree)}function useRecoilValue(recoilValue){return handleLoadable(useRecoilValueLoadable(recoilValue),recoilValue,storeRef)}return{getRecoilValue:useRecoilValue,getRecoilValueLoadable:useRecoilValueLoadable,getRecoilState:function useRecoilState(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},getRecoilStateLoadable:function useRecoilStateLoadable(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},getSetRecoilState:useSetRecoilState,getResetRecoilState:function useResetRecoilState(recoilState){return()=>setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}}}),[recoilValuesUsed,storeRef])},useRecoilState:function useRecoilState(recoilState){return[useRecoilValue(recoilState),useSetRecoilState(recoilState)]},useRecoilStateLoadable:function useRecoilStateLoadable(recoilState){return[useRecoilValueLoadable(recoilState),useSetRecoilState(recoilState)]},useRecoilValue:useRecoilValue,useRecoilValueLoadable:useRecoilValueLoadable,useResetRecoilState:function useResetRecoilState(recoilState){const storeRef=useStoreRef$2();return useCallback$1((()=>{setRecoilValue$2(storeRef.current,recoilState,DEFAULT_VALUE$2)}),[storeRef,recoilState])},useSetRecoilState:useSetRecoilState,useSetUnvalidatedAtomValues:function useSetUnvalidatedAtomValues(){const storeRef=useStoreRef$2();return(values,transactionMetadata={})=>{batchUpdates$2((()=>{storeRef.current.addTransactionMetadata(transactionMetadata),values.forEach(((value,key)=>setUnvalidatedRecoilValue$2(storeRef.current,new AbstractRecoilValue$3(key),value)))}))}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState){return[useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState),useSetRecoilState(recoilState)]}};var Recoil_filterMap=function filterMap(map,callback){const result=new Map;for(const[key,value]of map)callback(value,key)&&result.set(key,value);return result};var Recoil_filterSet=function filterSet(set,callback){const result=new Set;for(const value of set)callback(value)&&result.add(value);return result};var Recoil_mergeMaps=function mergeMaps(...maps){const result=new Map;for(let i=0;i<maps.length;i++){const iterator=maps[i].keys();let nextKey;for(;!(nextKey=iterator.next()).done;)result.set(nextKey.value,maps[i].get(nextKey.value))}return result};const{batchUpdates:batchUpdates$3}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$3,getNode:getNode$4,nodes:nodes$1}=Recoil_Node,{useStoreRef:useStoreRef$3}=Recoil_RecoilRoot,{AbstractRecoilValue:AbstractRecoilValue$4,setRecoilValueLoadable:setRecoilValueLoadable$1}=Recoil_RecoilValueInterface,{SUSPENSE_TIMEOUT_MS:SUSPENSE_TIMEOUT_MS$2}=Recoil_Retention,{cloneSnapshot:cloneSnapshot$1}=Recoil_Snapshot$1,{useCallback:useCallback$2,useEffect:useEffect$4,useRef:useRef$5,useState:useState$2}=react__WEBPACK_IMPORTED_MODULE_0__,{isSSR:isSSR$4}=Recoil_Environment;function useTransactionSubscription(callback){const storeRef=useStoreRef$3();useEffect$4((()=>storeRef.current.subscribeToTransactions(callback).release),[callback,storeRef])}function externallyVisibleAtomValuesInState(state){const atomValues=state.atomValues.toMap(),persistedAtomContentsValues=Recoil_mapMap(Recoil_filterMap(atomValues,((v,k)=>{const persistence=getNode$4(k).persistence_UNSTABLE;return null!=persistence&&"none"!==persistence.type&&"hasValue"===v.state})),(v=>v.contents));return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(),persistedAtomContentsValues)}function gotoSnapshot(store,snapshot){var _storeState$nextTree;const storeState=store.getState(),prev=null!==(_storeState$nextTree=storeState.nextTree)&&void 0!==_storeState$nextTree?_storeState$nextTree:storeState.currentTree,next=snapshot.getStore_INTERNAL().getState().currentTree;batchUpdates$3((()=>{const keysToUpdate=new Set;for(const keys of[prev.atomValues.keys(),next.atomValues.keys()])for(const key of keys){var _prev$atomValues$get,_next$atomValues$get;(null===(_prev$atomValues$get=prev.atomValues.get(key))||void 0===_prev$atomValues$get?void 0:_prev$atomValues$get.contents)!==(null===(_next$atomValues$get=next.atomValues.get(key))||void 0===_next$atomValues$get?void 0:_next$atomValues$get.contents)&&getNode$4(key).shouldRestoreFromSnapshots&&keysToUpdate.add(key)}keysToUpdate.forEach((key=>{setRecoilValueLoadable$1(store,new AbstractRecoilValue$4(key),next.atomValues.has(key)?Recoil_nullthrows(next.atomValues.get(key)):DEFAULT_VALUE$3)})),store.replaceState((state=>({...state,stateID:snapshot.getID()})))}))}var Recoil_SnapshotHooks={useRecoilSnapshot:function useRecoilSnapshot(){const storeRef=useStoreRef$3(),[snapshot,setSnapshot]=useState$2((()=>cloneSnapshot$1(storeRef.current))),previousSnapshot=Recoil_usePrevious(snapshot),timeoutID=useRef$5(),releaseRef=useRef$5();if(useTransactionSubscription(useCallback$2((store=>setSnapshot(cloneSnapshot$1(store))),[])),useEffect$4((()=>{const release=snapshot.retain();var _releaseRef$current;timeoutID.current&&!isSSR$4&&(window.clearTimeout(timeoutID.current),timeoutID.current=null,null===(_releaseRef$current=releaseRef.current)||void 0===_releaseRef$current||_releaseRef$current.call(releaseRef),releaseRef.current=null);return()=>{window.setTimeout(release,10)}}),[snapshot]),previousSnapshot!==snapshot&&!isSSR$4){var _releaseRef$current2;if(timeoutID.current)window.clearTimeout(timeoutID.current),timeoutID.current=null,null===(_releaseRef$current2=releaseRef.current)||void 0===_releaseRef$current2||_releaseRef$current2.call(releaseRef),releaseRef.current=null;releaseRef.current=snapshot.retain(),timeoutID.current=window.setTimeout((()=>{var _releaseRef$current3;timeoutID.current=null,null===(_releaseRef$current3=releaseRef.current)||void 0===_releaseRef$current3||_releaseRef$current3.call(releaseRef),releaseRef.current=null}),SUSPENSE_TIMEOUT_MS$2)}return snapshot},gotoSnapshot:gotoSnapshot,useGotoRecoilSnapshot:function useGotoRecoilSnapshot(){const storeRef=useStoreRef$3();return useCallback$2((snapshot=>gotoSnapshot(storeRef.current,snapshot)),[storeRef])},useRecoilTransactionObserver:function useRecoilTransactionObserver(callback){useTransactionSubscription(useCallback$2((store=>{const snapshot=cloneSnapshot$1(store,"latest"),previousSnapshot=cloneSnapshot$1(store,"previous");callback({snapshot:snapshot,previousSnapshot:previousSnapshot})}),[callback]))},useTransactionObservation_DEPRECATED:function useTransactionObservation_DEPRECATED(callback){useTransactionSubscription(useCallback$2((store=>{let previousTree=store.getState().previousTree;const currentTree=store.getState().currentTree;previousTree||(Recoil_recoverableViolation("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),previousTree=store.getState().currentTree);const atomValues=externallyVisibleAtomValuesInState(currentTree),previousAtomValues=externallyVisibleAtomValuesInState(previousTree),atomInfo=Recoil_mapMap(nodes$1,(node=>{var _node$persistence_UNS,_node$persistence_UNS2,_node$persistence_UNS3,_node$persistence_UNS4;return{persistence_UNSTABLE:{type:null!==(_node$persistence_UNS=null===(_node$persistence_UNS2=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS2?void 0:_node$persistence_UNS2.type)&&void 0!==_node$persistence_UNS?_node$persistence_UNS:"none",backButton:null!==(_node$persistence_UNS3=null===(_node$persistence_UNS4=node.persistence_UNSTABLE)||void 0===_node$persistence_UNS4?void 0:_node$persistence_UNS4.backButton)&&void 0!==_node$persistence_UNS3&&_node$persistence_UNS3}}})),modifiedAtoms=Recoil_filterSet(currentTree.dirtyAtoms,(k=>atomValues.has(k)||previousAtomValues.has(k)));callback({atomValues:atomValues,previousAtomValues:previousAtomValues,atomInfo:atomInfo,modifiedAtoms:modifiedAtoms,transactionMetadata:{...currentTree.transactionMetadata}})}),[callback]))},useTransactionSubscription_DEPRECATED:useTransactionSubscription};const{peekNodeInfo:peekNodeInfo$2}=Recoil_FunctionalCore,{useStoreRef:useStoreRef$4}=Recoil_RecoilRoot;var Recoil_useGetRecoilValueInfo=function useGetRecoilValueInfo(){const storeRef=useStoreRef$4();return({key:key})=>peekNodeInfo$2(storeRef.current,storeRef.current.getState().currentTree,key)};const{reactMode:reactMode$4}=Recoil_ReactMode,{RecoilRoot:RecoilRoot$1,useStoreRef:useStoreRef$5}=Recoil_RecoilRoot,{useMemo:useMemo$2}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRecoilBridgeAcrossReactRoots=function useRecoilBridgeAcrossReactRoots(){"MUTABLE_SOURCE"===reactMode$4().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const store=useStoreRef$5().current;return useMemo$2((()=>function RecoilBridge({children:children}){return react__WEBPACK_IMPORTED_MODULE_0__.createElement(RecoilRoot$1,{store_INTERNAL:store},children)}),[store])};const{loadableWithValue:loadableWithValue$1}=Recoil_Loadable$1,{initializeNode:initializeNode$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$4,getNode:getNode$5}=Recoil_Node,{copyTreeState:copyTreeState$1,getRecoilValueAsLoadable:getRecoilValueAsLoadable$3,invalidateDownstreams:invalidateDownstreams$1,writeLoadableToTreeState:writeLoadableToTreeState$1}=Recoil_RecoilValueInterface;function isAtom(recoilValue){return"atom"===getNode$5(recoilValue.key).nodeType}class TransactionInterfaceImpl{constructor(store,treeState){_defineProperty(this,"_store",void 0),_defineProperty(this,"_treeState",void 0),_defineProperty(this,"_changes",void 0),_defineProperty(this,"get",(recoilValue=>{if(this._changes.has(recoilValue.key))return this._changes.get(recoilValue.key);if(!isAtom(recoilValue))throw Recoil_err("Reading selectors within atomicUpdate is not supported");const loadable=getRecoilValueAsLoadable$3(this._store,recoilValue,this._treeState);if("hasValue"===loadable.state)return loadable.contents;throw"hasError"===loadable.state?loadable.contents:Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`)})),_defineProperty(this,"set",((recoilState,valueOrUpdater)=>{if(!isAtom(recoilState))throw Recoil_err("Setting selectors within atomicUpdate is not supported");if("function"==typeof valueOrUpdater){const current=this.get(recoilState);this._changes.set(recoilState.key,valueOrUpdater(current))}else initializeNode$3(this._store,recoilState.key,"set"),this._changes.set(recoilState.key,valueOrUpdater)})),_defineProperty(this,"reset",(recoilState=>{this.set(recoilState,DEFAULT_VALUE$4)})),this._store=store,this._treeState=treeState,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const newState=copyTreeState$1(this._treeState);for(const[k,v]of this._changes)writeLoadableToTreeState$1(newState,k,loadableWithValue$1(v));return invalidateDownstreams$1(this._store,newState),newState}}var Recoil_AtomicUpdates_1=function atomicUpdater(store){return fn=>{store.replaceState((treeState=>{const changeset=new TransactionInterfaceImpl(store,treeState);return fn(changeset),changeset.newTreeState_INTERNAL()}))}},Recoil_AtomicUpdates$1=Object.freeze({__proto__:null,atomicUpdater:Recoil_AtomicUpdates_1});var Recoil_invariant=function invariant(condition,message){if(!condition)throw new Error(message)};const{atomicUpdater:atomicUpdater$1}=Recoil_AtomicUpdates$1,{batchUpdates:batchUpdates$4}=Recoil_Batching,{DEFAULT_VALUE:DEFAULT_VALUE$5}=Recoil_Node,{useStoreRef:useStoreRef$6}=Recoil_RecoilRoot,{refreshRecoilValue:refreshRecoilValue$1,setRecoilValue:setRecoilValue$3}=Recoil_RecoilValueInterface,{cloneSnapshot:cloneSnapshot$2}=Recoil_Snapshot$1,{gotoSnapshot:gotoSnapshot$1}=Recoil_SnapshotHooks,{useCallback:useCallback$3}=react__WEBPACK_IMPORTED_MODULE_0__;class Sentinel{}const SENTINEL=new Sentinel;function recoilCallback(store,fn,args,extraInterface){let releaseSnapshot,ret=SENTINEL;var _releaseSnapshot2;(batchUpdates$4((()=>{const errMsg="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!=typeof fn)throw Recoil_err(errMsg);const callbackInterface=Recoil_lazyProxy({...null!=extraInterface?extraInterface:{},set:(node,newValue)=>setRecoilValue$3(store,node,newValue),reset:node=>setRecoilValue$3(store,node,DEFAULT_VALUE$5),refresh:node=>refreshRecoilValue$1(store,node),gotoSnapshot:snapshot=>gotoSnapshot$1(store,snapshot),transact_UNSTABLE:transaction=>atomicUpdater$1(store)(transaction)},{snapshot:()=>{const snapshot=cloneSnapshot$2(store);return releaseSnapshot=snapshot.retain(),snapshot}}),callback=fn(callbackInterface);if("function"!=typeof callback)throw Recoil_err(errMsg);ret=callback(...args)})),ret instanceof Sentinel&&Recoil_invariant(!1),Recoil_isPromise(ret))?ret=ret.finally((()=>{var _releaseSnapshot;null===(_releaseSnapshot=releaseSnapshot)||void 0===_releaseSnapshot||_releaseSnapshot()})):null===(_releaseSnapshot2=releaseSnapshot)||void 0===_releaseSnapshot2||_releaseSnapshot2();return ret}var Recoil_useRecoilCallback={recoilCallback:recoilCallback,useRecoilCallback:function useRecoilCallback(fn,deps){const storeRef=useStoreRef$6();return useCallback$3(((...args)=>recoilCallback(storeRef.current,fn,args)),null!=deps?[...deps,storeRef]:void 0)}};const{useStoreRef:useStoreRef$7}=Recoil_RecoilRoot,{refreshRecoilValue:refreshRecoilValue$2}=Recoil_RecoilValueInterface,{useCallback:useCallback$4}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRecoilRefresher=function useRecoilRefresher(recoilValue){const storeRef=useStoreRef$7();return useCallback$4((()=>{const store=storeRef.current;refreshRecoilValue$2(store,recoilValue)}),[recoilValue,storeRef])};const{atomicUpdater:atomicUpdater$2}=Recoil_AtomicUpdates$1,{useStoreRef:useStoreRef$8}=Recoil_RecoilRoot,{useMemo:useMemo$3}=react__WEBPACK_IMPORTED_MODULE_0__;var Recoil_useRecoilTransaction=function useRecoilTransaction(fn,deps){const storeRef=useStoreRef$8();return useMemo$3((()=>(...args)=>{atomicUpdater$2(storeRef.current)((transactionInterface=>{fn(transactionInterface)(...args)}))}),null!=deps?[...deps,storeRef]:void 0)};var Recoil_Wrapper_1=class WrappedValue{constructor(value){_defineProperty(this,"value",void 0),this.value=value}},Recoil_Wrapper$1=Object.freeze({__proto__:null,WrappedValue:Recoil_Wrapper_1});const{isFastRefreshEnabled:isFastRefreshEnabled$2}=Recoil_ReactMode;class ChangedPathError extends Error{}var Recoil_TreeCache_1=class TreeCache{constructor(options){var _options$onHit,_options$onSet,_options$mapNodeValue;_defineProperty(this,"_name",void 0),_defineProperty(this,"_numLeafs",void 0),_defineProperty(this,"_root",void 0),_defineProperty(this,"_onHit",void 0),_defineProperty(this,"_onSet",void 0),_defineProperty(this,"_mapNodeValue",void 0),this._name=null==options?void 0:options.name,this._numLeafs=0,this._root=null,this._onHit=null!==(_options$onHit=null==options?void 0:options.onHit)&&void 0!==_options$onHit?_options$onHit:()=>{},this._onSet=null!==(_options$onSet=null==options?void 0:options.onSet)&&void 0!==_options$onSet?_options$onSet:()=>{},this._mapNodeValue=null!==(_options$mapNodeValue=null==options?void 0:options.mapNodeValue)&&void 0!==_options$mapNodeValue?_options$mapNodeValue:val=>val}size(){return this._numLeafs}root(){return this._root}get(getNodeValue,handlers){var _this$getLeafNode;return null===(_this$getLeafNode=this.getLeafNode(getNodeValue,handlers))||void 0===_this$getLeafNode?void 0:_this$getLeafNode.value}getLeafNode(getNodeValue,handlers){if(null==this._root)return;let node=this._root;for(;node;){if(null==handlers||handlers.onNodeVisit(node),"leaf"===node.type)return this._onHit(node),node;const nodeValue=this._mapNodeValue(getNodeValue(node.nodeKey));node=node.branches.get(nodeValue)}}set(route,value,handlers){const addLeaf=()=>{var _node2,_node3,_this$_root2,_handlers$onNodeVisit2;let node,branchKey;for(const[nodeKey,nodeValue]of route){var _node,_handlers$onNodeVisit,_this$_root;const root=this._root;if("leaf"===(null==root?void 0:root.type))throw this.invalidCacheError();const parent=node;if(node=parent?parent.branches.get(branchKey):root,node=null!==(_node=node)&&void 0!==_node?_node:{type:"branch",nodeKey:nodeKey,parent:parent,branches:new Map,branchKey:branchKey},"branch"!==node.type||node.nodeKey!==nodeKey)throw this.invalidCacheError();null==parent||parent.branches.set(branchKey,node),null==handlers||null===(_handlers$onNodeVisit=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit||_handlers$onNodeVisit.call(handlers,node),branchKey=this._mapNodeValue(nodeValue),this._root=null!==(_this$_root=this._root)&&void 0!==_this$_root?_this$_root:node}const oldLeaf=node?null===(_node2=node)||void 0===_node2?void 0:_node2.branches.get(branchKey):this._root;if(null!=oldLeaf&&("leaf"!==oldLeaf.type||oldLeaf.branchKey!==branchKey))throw this.invalidCacheError();const leafNode={type:"leaf",value:value,parent:node,branchKey:branchKey};null===(_node3=node)||void 0===_node3||_node3.branches.set(branchKey,leafNode),this._root=null!==(_this$_root2=this._root)&&void 0!==_this$_root2?_this$_root2:leafNode,this._numLeafs++,this._onSet(leafNode),null==handlers||null===(_handlers$onNodeVisit2=handlers.onNodeVisit)||void 0===_handlers$onNodeVisit2||_handlers$onNodeVisit2.call(handlers,leafNode)};try{addLeaf()}catch(error){if(!(error instanceof ChangedPathError))throw error;this.clear(),addLeaf()}}delete(leaf){const root=this.root();if(!root)return!1;if(leaf===root)return this._root=null,this._numLeafs=0,!0;let node=leaf.parent,branchKey=leaf.branchKey;for(;node;){var _node4;if(node.branches.delete(branchKey),node===root)return 0===node.branches.size?(this._root=null,this._numLeafs=0):this._numLeafs--,!0;if(node.branches.size>0)break;branchKey=null===(_node4=node)||void 0===_node4?void 0:_node4.branchKey,node=node.parent}for(;node!==root;node=node.parent)if(null==node)return!1;return this._numLeafs--,!0}clear(){this._numLeafs=0,this._root=null}invalidCacheError(){const CHANGED_PATH_ERROR_MESSAGE=isFastRefreshEnabled$2()?"Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache.":"Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";throw Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE+(null!=this._name?` - ${this._name}`:"")),new ChangedPathError}},Recoil_TreeCache$1=Object.freeze({__proto__:null,TreeCache:Recoil_TreeCache_1});var Recoil_LRUCache_1=class LRUCache{constructor(options){var _options$mapKey;_defineProperty(this,"_maxSize",void 0),_defineProperty(this,"_size",void 0),_defineProperty(this,"_head",void 0),_defineProperty(this,"_tail",void 0),_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._maxSize=options.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(_options$mapKey=options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(key){return this._map.has(this._keyMapper(key))}get(key){const mappedKey=this._keyMapper(key),node=this._map.get(mappedKey);if(node)return this.set(key,node.value),node.value}set(key,val){const mappedKey=this._keyMapper(key);this._map.get(mappedKey)&&this.delete(key);const head=this.head(),node={key:key,right:head,left:null,value:val};head?head.left=node:this._tail=node,this._map.set(mappedKey,node),this._head=node,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const tail=this.tail();tail&&this.delete(tail.key)}delete(key){const mappedKey=this._keyMapper(key);if(!this._size||!this._map.has(mappedKey))return;const node=Recoil_nullthrows(this._map.get(mappedKey)),right=node.right,left=node.left;right&&(right.left=node.left),left&&(left.right=node.right),node===this.head()&&(this._head=right),node===this.tail()&&(this._tail=left),this._map.delete(mappedKey),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},Recoil_LRUCache$1=Object.freeze({__proto__:null,LRUCache:Recoil_LRUCache_1});const{LRUCache:LRUCache$1}=Recoil_LRUCache$1,{TreeCache:TreeCache$1}=Recoil_TreeCache$1;var Recoil_treeCacheLRU=function treeCacheLRU({name:name,maxSize:maxSize,mapNodeValue:mapNodeValue=(v=>v)}){const lruCache=new LRUCache$1({maxSize:maxSize}),cache=new TreeCache$1({name:name,mapNodeValue:mapNodeValue,onHit:node=>{lruCache.set(node,!0)},onSet:node=>{const lruNode=lruCache.tail();lruCache.set(node,!0),lruNode&&cache.size()>maxSize&&cache.delete(lruNode.key)}});return cache};function stringify(x,opt,key){if("string"==typeof x&&!x.includes('"')&&!x.includes("\\"))return`"${x}"`;switch(typeof x){case"undefined":return"";case"boolean":return x?"true":"false";case"number":case"symbol":return String(x);case"string":return JSON.stringify(x);case"function":if(!0!==(null==opt?void 0:opt.allowFunctions))throw Recoil_err("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${x.name})__`}if(null===x)return"null";var _JSON$stringify;if("object"!=typeof x)return null!==(_JSON$stringify=JSON.stringify(x))&&void 0!==_JSON$stringify?_JSON$stringify:"";if(Recoil_isPromise(x))return"__PROMISE__";if(Array.isArray(x))return`[${x.map(((v,i)=>stringify(v,opt,i.toString())))}]`;if("function"==typeof x.toJSON)return stringify(x.toJSON(key),opt,key);if(x instanceof Map){const obj={};for(const[k,v]of x)obj["string"==typeof k?k:stringify(k,opt)]=v;return stringify(obj,opt,key)}return x instanceof Set?stringify(Array.from(x).sort(((a,b)=>stringify(a,opt).localeCompare(stringify(b,opt)))),opt,key):void 0!==Symbol&&null!=x[Symbol.iterator]&&"function"==typeof x[Symbol.iterator]?stringify(Array.from(x),opt,key):`{${Object.keys(x).filter((k=>void 0!==x[k])).sort().map((k=>`${stringify(k,opt)}:${stringify(x[k],opt,k)}`)).join(",")}}`}var Recoil_stableStringify=function stableStringify(x,opt={allowFunctions:!1}){return stringify(x,opt)};const{TreeCache:TreeCache$2}=Recoil_TreeCache$1,defaultPolicy={equality:"reference",eviction:"keep-all",maxSize:1/0};var Recoil_treeCacheFromPolicy=function treeCacheFromPolicy({equality:equality=defaultPolicy.equality,eviction:eviction=defaultPolicy.eviction,maxSize:maxSize=defaultPolicy.maxSize}=defaultPolicy,name){const valueMapper=function getValueMapper(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw Recoil_err(`Unrecognized equality policy ${equality}`)}(equality);return function getTreeCache(eviction,maxSize,mapNodeValue,name){switch(eviction){case"keep-all":return new TreeCache$2({name:name,mapNodeValue:mapNodeValue});case"lru":return Recoil_treeCacheLRU({name:name,maxSize:Recoil_nullthrows(maxSize),mapNodeValue:mapNodeValue});case"most-recent":return Recoil_treeCacheLRU({name:name,maxSize:1,mapNodeValue:mapNodeValue})}throw Recoil_err(`Unrecognized eviction policy ${eviction}`)}(eviction,maxSize,valueMapper,name)};const{isReactNative:isReactNative$1,isWindow:isWindow$1}=Recoil_Environment;var Recoil_PerformanceTimings={startPerfBlock:function startPerfBlock(_id){return()=>null}};const{isLoadable:isLoadable$1,loadableWithError:loadableWithError$1,loadableWithPromise:loadableWithPromise$1,loadableWithValue:loadableWithValue$2}=Recoil_Loadable$1,{WrappedValue:WrappedValue$1}=Recoil_Wrapper$1,{getNodeLoadable:getNodeLoadable$2,peekNodeLoadable:peekNodeLoadable$1,setNodeValue:setNodeValue$3}=Recoil_FunctionalCore,{saveDepsToStore:saveDepsToStore$1}=Recoil_Graph,{DEFAULT_VALUE:DEFAULT_VALUE$6,getConfigDeletionHandler:getConfigDeletionHandler$1,getNode:getNode$6,registerNode:registerNode$1}=Recoil_Node,{isRecoilValue:isRecoilValue$3}=Recoil_RecoilValue$1,{markRecoilValueModified:markRecoilValueModified$1}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$1}=Recoil_Retention,{recoilCallback:recoilCallback$1}=Recoil_useRecoilCallback,{startPerfBlock:startPerfBlock$1}=Recoil_PerformanceTimings;class Canceled{}const CANCELED=new Canceled,dependencyStack=[],waitingStores=new Map,getNewExecutionID=(()=>{let executionID=0;return()=>executionID++})();function selector(options){let recoilValue=null;const{key:key,get:get,cachePolicy_UNSTABLE:cachePolicy}=options,set=null!=options.set?options.set:void 0;const discoveredDependencyNodeKeys=new Set,cache=Recoil_treeCacheFromPolicy(null!=cachePolicy?cachePolicy:{equality:"reference",eviction:"keep-all"},key),retainedBy=retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE),executionInfoMap=new Map;let liveStoresCount=0;function selectorIsLive(){return!Recoil_gkx("recoil_memory_managament_2020")||liveStoresCount>0}function selectorInit(store){return store.getState().knownSelectors.add(key),liveStoresCount++,()=>{liveStoresCount--}}function selectorShouldDeleteConfigOnRelease(){return void 0!==getConfigDeletionHandler$1(key)&&!selectorIsLive()}function resolveAsync(store,state,executionID,loadable,depValues){setCache(state,loadable,depValues),notifyStoresOfResolvedAsync(store,executionID)}function notifyStoresOfResolvedAsync(store,executionID){isLatestExecution(store,executionID)&&clearExecutionInfo(store),notifyWaitingStores(executionID,!0)}function notifyWaitingStores(executionID,clearWaitlist){const stores=waitingStores.get(executionID);if(null!=stores){for(const waitingStore of stores)markRecoilValueModified$1(waitingStore,Recoil_nullthrows(recoilValue));clearWaitlist&&waitingStores.delete(executionID)}}function markStoreWaitingForResolvedAsync(store,executionID){let stores=waitingStores.get(executionID);null==stores&&waitingStores.set(executionID,stores=new Set),stores.add(store)}function wrapPendingDependencyPromise(store,promise,state,existingDeps,executionID,loadingDepsState){return promise.then((resolvedDep=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;null!=loadingDepsState.loadingDepKey&&loadingDepsState.loadingDepPromise===promise?state.atomValues.set(loadingDepsState.loadingDepKey,loadableWithValue$2(resolvedDep)):store.getState().knownSelectors.forEach((nodeKey=>{state.atomValues.delete(nodeKey)}));const cachedLoadable=getLoadableFromCacheAndUpdateDeps(store,state);if(cachedLoadable&&"loading"!==cachedLoadable.state){if((isLatestExecution(store,executionID)||null==getExecutionInfo(store))&&notifyStoresOfResolvedAsync(store,executionID),"hasValue"===cachedLoadable.state)return cachedLoadable.contents;throw cachedLoadable.contents}if(!isLatestExecution(store,executionID)){const executionInfo=getInProgressExecutionInfo(store,state);if(null!=executionInfo)return executionInfo.loadingLoadable.contents}const[loadable,depValues]=evaluateSelectorGetter(store,state,executionID);if("loading"!==loadable.state&&resolveAsync(store,state,executionID,loadable,depValues),"hasError"===loadable.state)throw loadable.contents;return loadable.contents})).catch((error=>{if(error instanceof Canceled)throw CANCELED;if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;const loadable=loadableWithError$1(error);throw resolveAsync(store,state,executionID,loadable,existingDeps),error}))}function updateDeps(store,state,deps,executionID){var _store$getState,_store$getState$curre,_store$getState2,_store$getState2$next,_store$getState$nextT,_store$getState3,_store$getState3$next;(isLatestExecution(store,executionID)||state.version===(null===(_store$getState=store.getState())||void 0===_store$getState||null===(_store$getState$curre=_store$getState.currentTree)||void 0===_store$getState$curre?void 0:_store$getState$curre.version)||state.version===(null===(_store$getState2=store.getState())||void 0===_store$getState2||null===(_store$getState2$next=_store$getState2.nextTree)||void 0===_store$getState2$next?void 0:_store$getState2$next.version))&&saveDepsToStore$1(key,deps,store,null!==(_store$getState$nextT=null===(_store$getState3=store.getState())||void 0===_store$getState3||null===(_store$getState3$next=_store$getState3.nextTree)||void 0===_store$getState3$next?void 0:_store$getState3$next.version)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree.version);for(const nodeKey of deps)discoveredDependencyNodeKeys.add(nodeKey)}function evaluateSelectorGetter(store,state,executionID){const endPerfBlock=startPerfBlock$1(key);let duringSynchronousExecution=!0,duringAsynchronousExecution=!0;const finishEvaluation=()=>{endPerfBlock(),duringAsynchronousExecution=!1};let result,loadable,resultIsError=!1;const loadingDepsState={loadingDepKey:null,loadingDepPromise:null},depValues=new Map;function getRecoilValue({key:depKey}){const depLoadable=getNodeLoadable$2(store,state,depKey);switch(depValues.set(depKey,depLoadable),duringSynchronousExecution||(updateDeps(store,state,new Set(depValues.keys()),executionID),function notifyStoresOfNewAsyncDep(store,executionID){isLatestExecution(store,executionID)&&(Recoil_nullthrows(getExecutionInfo(store)).stateVersions.clear(),notifyWaitingStores(executionID,!1))}(store,executionID)),depLoadable.state){case"hasValue":return depLoadable.contents;case"hasError":throw depLoadable.contents;case"loading":throw loadingDepsState.loadingDepKey=depKey,loadingDepsState.loadingDepPromise=depLoadable.contents,depLoadable.contents}throw Recoil_err("Invalid Loadable state")}const getCallback=fn=>(...args)=>{if(duringAsynchronousExecution)throw Recoil_err("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==recoilValue&&Recoil_invariant(!1),recoilCallback$1(store,fn,args,{node:recoilValue})};try{result=get({get:getRecoilValue,getCallback:getCallback}),result=isRecoilValue$3(result)?getRecoilValue(result):result,isLoadable$1(result)&&("hasError"===result.state&&(resultIsError=!0),result=result.contents),Recoil_isPromise(result)?result=function wrapResultPromise(store,promise,state,depValues,executionID,loadingDepsState){return promise.then((value=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;const loadable=loadableWithValue$2(value);return resolveAsync(store,state,executionID,loadable,depValues),value})).catch((errorOrPromise=>{if(!selectorIsLive())throw clearExecutionInfo(store),CANCELED;if(Recoil_isPromise(errorOrPromise))return wrapPendingDependencyPromise(store,errorOrPromise,state,depValues,executionID,loadingDepsState);const loadable=loadableWithError$1(errorOrPromise);throw resolveAsync(store,state,executionID,loadable,depValues),errorOrPromise}))}(store,result,state,depValues,executionID,loadingDepsState).finally(finishEvaluation):finishEvaluation(),result=result instanceof WrappedValue$1?result.value:result}catch(errorOrDepPromise){result=errorOrDepPromise,Recoil_isPromise(result)?result=wrapPendingDependencyPromise(store,result,state,depValues,executionID,loadingDepsState).finally(finishEvaluation):(resultIsError=!0,finishEvaluation())}return loadable=resultIsError?loadableWithError$1(result):Recoil_isPromise(result)?loadableWithPromise$1(result):loadableWithValue$2(result),duringSynchronousExecution=!1,function updateExecutionInfoDepValues(store,executionID,depValues){if(isLatestExecution(store,executionID)){const executionInfo=getExecutionInfo(store);null!=executionInfo&&(executionInfo.depValuesDiscoveredSoFarDuringAsyncWork=depValues)}}(store,executionID,depValues),updateDeps(store,state,new Set(depValues.keys()),executionID),[loadable,depValues]}function getLoadableFromCacheAndUpdateDeps(store,state){let cachedLoadable=state.atomValues.get(key);if(null!=cachedLoadable)return cachedLoadable;const depsAfterCacheLookup=new Set;try{cachedLoadable=cache.get((nodeKey=>("string"!=typeof nodeKey&&Recoil_invariant(!1),getNodeLoadable$2(store,state,nodeKey).contents)),{onNodeVisit:node=>{"branch"===node.type&&node.nodeKey!==key&&depsAfterCacheLookup.add(node.nodeKey)}})}catch(error){throw Recoil_err(`Problem with cache lookup for selector "${key}": ${error.message}`)}var _getExecutionInfo;cachedLoadable&&(state.atomValues.set(key,cachedLoadable),updateDeps(store,state,depsAfterCacheLookup,null===(_getExecutionInfo=getExecutionInfo(store))||void 0===_getExecutionInfo?void 0:_getExecutionInfo.executionID));return cachedLoadable}function getSelectorLoadableAndUpdateDeps(store,state){const cachedVal=getLoadableFromCacheAndUpdateDeps(store,state);if(null!=cachedVal)return clearExecutionInfo(store),cachedVal;const inProgressExecutionInfo=getInProgressExecutionInfo(store,state);var _inProgressExecutionI;if(null!=inProgressExecutionInfo)return"loading"===(null===(_inProgressExecutionI=inProgressExecutionInfo.loadingLoadable)||void 0===_inProgressExecutionI?void 0:_inProgressExecutionI.state)&&markStoreWaitingForResolvedAsync(store,inProgressExecutionInfo.executionID),inProgressExecutionInfo.loadingLoadable;const newExecutionID=getNewExecutionID(),[loadable,newDepValues]=evaluateSelectorGetter(store,state,newExecutionID);return"loading"===loadable.state?(!function setExecutionInfo(store,newExecutionID,loadable,depValues,state){executionInfoMap.set(store,{depValuesDiscoveredSoFarDuringAsyncWork:depValues,executionID:newExecutionID,loadingLoadable:loadable,stateVersions:new Map([[state.version,!0]])})}(store,newExecutionID,loadable,newDepValues,state),markStoreWaitingForResolvedAsync(store,newExecutionID)):(clearExecutionInfo(store),setCache(state,loadable,newDepValues)),loadable}function getInProgressExecutionInfo(store,state){const pendingExecutions=Recoil_concatIterables([executionInfoMap.has(store)?[Recoil_nullthrows(executionInfoMap.get(store))]:[],Recoil_mapIterable(Recoil_filterIterable(executionInfoMap,(([s])=>s!==store)),(([,execInfo])=>execInfo))]);function anyDepChanged(execDepValues){for(const[depKey,execLoadable]of execDepValues)if(!getNodeLoadable$2(store,state,depKey).is(execLoadable))return!0;return!1}for(const execInfo of pendingExecutions){if(execInfo.stateVersions.get(state.version)||!anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork))return execInfo.stateVersions.set(state.version,!0),execInfo;execInfo.stateVersions.set(state.version,!1)}}function getExecutionInfo(store){return executionInfoMap.get(store)}function clearExecutionInfo(store){executionInfoMap.delete(store)}function isLatestExecution(store,executionID){var _getExecutionInfo2;return executionID===(null===(_getExecutionInfo2=getExecutionInfo(store))||void 0===_getExecutionInfo2?void 0:_getExecutionInfo2.executionID)}function setCache(state,loadable,depValues){state.atomValues.set(key,loadable);try{cache.set(function depValuesToDepRoute(depValues){return Array.from(depValues.entries()).map((([depKey,valLoadable])=>[depKey,valLoadable.contents]))}(depValues),loadable)}catch(error){throw Recoil_err(`Problem with setting cache for selector "${key}": ${error.message}`)}}function selectorPeek(store,state){const cachedLoadable=state.atomValues.get(key);return null!=cachedLoadable?cachedLoadable:cache.get((nodeKey=>{var _peekNodeLoadable;return"string"!=typeof nodeKey&&Recoil_invariant(!1),null===(_peekNodeLoadable=peekNodeLoadable$1(store,state,nodeKey))||void 0===_peekNodeLoadable?void 0:_peekNodeLoadable.contents}))}function selectorGet(store,state){return function detectCircularDependencies(fn){if(dependencyStack.includes(key)){const message=`Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join(" → ")}`;return loadableWithError$1(Recoil_err(message))}dependencyStack.push(key);try{return fn()}finally{dependencyStack.pop()}}((()=>getSelectorLoadableAndUpdateDeps(store,state)))}function invalidateSelector(state){state.atomValues.delete(key)}function clearSelectorCache(store,treeState){null==recoilValue&&Recoil_invariant(!1);for(const nodeKey of discoveredDependencyNodeKeys){var _node$clearCache;const node=getNode$6(nodeKey);null===(_node$clearCache=node.clearCache)||void 0===_node$clearCache||_node$clearCache.call(node,store,treeState)}discoveredDependencyNodeKeys.clear(),invalidateSelector(treeState),cache.clear(),markRecoilValueModified$1(store,recoilValue)}if(null!=set){return recoilValue=registerNode$1({key:key,nodeType:"selector",peek:selectorPeek,get:selectorGet,set:(store,state,newValue)=>{let syncSelectorSetFinished=!1;const writes=new Map;function getRecoilValue({key:depKey}){if(syncSelectorSetFinished)throw Recoil_err("Recoil: Async selector sets are not currently supported.");const loadable=getNodeLoadable$2(store,state,depKey);if("hasValue"===loadable.state)return loadable.contents;if("loading"===loadable.state){const msg=`Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key}" is not yet supported.`;throw Recoil_recoverableViolation(msg),Recoil_err(msg)}throw loadable.contents}function setRecoilState(recoilState,valueOrUpdater){if(syncSelectorSetFinished){const msg="Recoil: Async selector sets are not currently supported.";throw Recoil_recoverableViolation(msg),Recoil_err(msg)}const setValue="function"==typeof valueOrUpdater?valueOrUpdater(getRecoilValue(recoilState)):valueOrUpdater;setNodeValue$3(store,state,recoilState.key,setValue).forEach(((v,k)=>writes.set(k,v)))}const ret=set({set:setRecoilState,get:getRecoilValue,reset:function resetRecoilState(recoilState){setRecoilState(recoilState,DEFAULT_VALUE$6)}},newValue);if(void 0!==ret)throw Recoil_isPromise(ret)?Recoil_err("Recoil: Async selector sets are not currently supported."):Recoil_err("Recoil: selector set should be a void function.");return syncSelectorSetFinished=!0,writes},init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:retainedBy})}return recoilValue=registerNode$1({key:key,nodeType:"selector",peek:selectorPeek,get:selectorGet,init:selectorInit,invalidate:invalidateSelector,clearCache:clearSelectorCache,shouldDeleteConfigOnRelease:selectorShouldDeleteConfigOnRelease,dangerouslyAllowMutability:options.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:retainedBy})}selector.value=value=>new WrappedValue$1(value);var Recoil_selector=selector;const{isLoadable:isLoadable$2,loadableWithError:loadableWithError$2,loadableWithPromise:loadableWithPromise$2,loadableWithValue:loadableWithValue$3}=Recoil_Loadable$1,{WrappedValue:WrappedValue$2}=Recoil_Wrapper$1,{peekNodeInfo:peekNodeInfo$3}=Recoil_FunctionalCore,{DEFAULT_VALUE:DEFAULT_VALUE$7,DefaultValue:DefaultValue$2,getConfigDeletionHandler:getConfigDeletionHandler$2,registerNode:registerNode$2,setConfigDeletionHandler:setConfigDeletionHandler$1}=Recoil_Node,{isRecoilValue:isRecoilValue$4}=Recoil_RecoilValue$1,{getRecoilValueAsLoadable:getRecoilValueAsLoadable$4,markRecoilValueModified:markRecoilValueModified$2,setRecoilValue:setRecoilValue$4,setRecoilValueLoadable:setRecoilValueLoadable$2}=Recoil_RecoilValueInterface,{retainedByOptionWithDefault:retainedByOptionWithDefault$2}=Recoil_Retention,unwrap=x=>x instanceof WrappedValue$2?x.value:x;function baseAtom(options){const{key:key,persistence_UNSTABLE:persistence}=options,retainedBy=retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);let liveStoresCount=0;function unwrapPromise(promise){return loadableWithPromise$2(promise.then((value=>(defaultLoadable=loadableWithValue$3(value),value))).catch((error=>{throw defaultLoadable=loadableWithError$2(error),error})))}let cachedAnswerForUnvalidatedValue,defaultLoadable=Recoil_isPromise(options.default)?unwrapPromise(options.default):isLoadable$2(options.default)?"loading"===options.default.state?unwrapPromise(options.default.contents):options.default:loadableWithValue$3(unwrap(options.default));maybeFreezeValueOrPromise(defaultLoadable.contents);const cleanupEffectsByStore=new Map;function maybeFreezeValueOrPromise(valueOrPromise){return valueOrPromise}function peekAtom(_store,state){var _ref,_state$atomValues$get3;return null!==(_ref=null!==(_state$atomValues$get3=state.atomValues.get(key))&&void 0!==_state$atomValues$get3?_state$atomValues$get3:cachedAnswerForUnvalidatedValue)&&void 0!==_ref?_ref:defaultLoadable}const node=registerNode$2({key:key,nodeType:"atom",peek:peekAtom,get:function getAtom(_store,state){if(state.atomValues.has(key))return Recoil_nullthrows(state.atomValues.get(key));if(state.nonvalidatedAtoms.has(key)){if(null!=cachedAnswerForUnvalidatedValue)return cachedAnswerForUnvalidatedValue;if(null==persistence)return Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`),defaultLoadable;const nonvalidatedValue=state.nonvalidatedAtoms.get(key),validatorResult=persistence.validator(nonvalidatedValue,DEFAULT_VALUE$7),validatedValueLoadable=validatorResult instanceof DefaultValue$2?defaultLoadable:loadableWithValue$3(validatorResult);return cachedAnswerForUnvalidatedValue=validatedValueLoadable,cachedAnswerForUnvalidatedValue}return defaultLoadable},set:function setAtom(_store,state,newValue){if(state.atomValues.has(key)){const existing=Recoil_nullthrows(state.atomValues.get(key));if("hasValue"===existing.state&&newValue===existing.contents)return new Map}else if(!state.nonvalidatedAtoms.has(key)&&newValue instanceof DefaultValue$2)return new Map;return cachedAnswerForUnvalidatedValue=void 0,(new Map).set(key,loadableWithValue$3(newValue))},init:function initAtom(store,initState,trigger){var _options$effects;if(liveStoresCount++,store.getState().knownAtoms.add(key),"loading"===defaultLoadable.state){const notifyDefaultSubscribers=()=>{var _store$getState$nextT3;(null!==(_store$getState$nextT3=store.getState().nextTree)&&void 0!==_store$getState$nextT3?_store$getState$nextT3:store.getState().currentTree).atomValues.has(key)||markRecoilValueModified$2(store,node)};defaultLoadable.contents.finally(notifyDefaultSubscribers)}const effects=null!==(_options$effects=options.effects)&&void 0!==_options$effects?_options$effects:options.effects_UNSTABLE;if(null!=effects){let initValue=DEFAULT_VALUE$7,isDuringInit=!0,isInitError=!1,pendingSetSelf=null;function getLoadable(recoilValue){if(isDuringInit&&recoilValue.key===key){const retValue=initValue;return retValue instanceof DefaultValue$2?peekAtom(store,initState):Recoil_isPromise(retValue)?loadableWithPromise$2(retValue.then((v=>v instanceof DefaultValue$2?defaultLoadable.toPromise():v))):loadableWithValue$3(retValue)}return getRecoilValueAsLoadable$4(store,recoilValue)}function getPromise(recoilValue){return getLoadable(recoilValue).toPromise()}function getInfo_UNSTABLE(recoilValue){var _store$getState$nextT4;const info=peekNodeInfo$3(store,null!==(_store$getState$nextT4=store.getState().nextTree)&&void 0!==_store$getState$nextT4?_store$getState$nextT4:store.getState().currentTree,recoilValue.key);return!isDuringInit||recoilValue.key!==key||initValue instanceof DefaultValue$2?info:{...info,isSet:!0,loadable:getLoadable(recoilValue)}}const setSelf=effect=>valueOrUpdater=>{if(isDuringInit){const currentLoadable=getLoadable(node),currentValue="hasValue"===currentLoadable.state?currentLoadable.contents:DEFAULT_VALUE$7;initValue="function"==typeof valueOrUpdater?valueOrUpdater(currentValue):valueOrUpdater,Recoil_isPromise(initValue)&&(initValue=initValue.then((value=>(pendingSetSelf={effect:effect,value:value},value))))}else{if(Recoil_isPromise(valueOrUpdater))throw Recoil_err("Setting atoms to async values is not implemented.");"function"!=typeof valueOrUpdater&&(pendingSetSelf={effect:effect,value:unwrap(valueOrUpdater)}),setRecoilValue$4(store,node,"function"==typeof valueOrUpdater?currentValue=>{const newValue=unwrap(valueOrUpdater(currentValue));return pendingSetSelf={effect:effect,value:newValue},newValue}:unwrap(valueOrUpdater))}},resetSelf=effect=>()=>setSelf(effect)(DEFAULT_VALUE$7),onSet=effect=>handler=>{var _cleanupEffectsByStor2;const{release:release}=store.subscribeToTransactions((currentStore=>{var _currentTree$atomValu;let{currentTree:currentTree,previousTree:previousTree}=currentStore.getState();previousTree||(Recoil_recoverableViolation("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),previousTree=currentTree);const newLoadable=null!==(_currentTree$atomValu=currentTree.atomValues.get(key))&&void 0!==_currentTree$atomValu?_currentTree$atomValu:defaultLoadable;if("hasValue"===newLoadable.state){var _previousTree$atomVal,_pendingSetSelf,_pendingSetSelf2,_pendingSetSelf3;const newValue=newLoadable.contents,oldLoadable=null!==(_previousTree$atomVal=previousTree.atomValues.get(key))&&void 0!==_previousTree$atomVal?_previousTree$atomVal:defaultLoadable,oldValue="hasValue"===oldLoadable.state?oldLoadable.contents:DEFAULT_VALUE$7;(null===(_pendingSetSelf=pendingSetSelf)||void 0===_pendingSetSelf?void 0:_pendingSetSelf.effect)!==effect||(null===(_pendingSetSelf2=pendingSetSelf)||void 0===_pendingSetSelf2?void 0:_pendingSetSelf2.value)!==newValue?handler(newValue,oldValue,!currentTree.atomValues.has(key)):(null===(_pendingSetSelf3=pendingSetSelf)||void 0===_pendingSetSelf3?void 0:_pendingSetSelf3.effect)===effect&&(pendingSetSelf=null)}}),key);cleanupEffectsByStore.set(store,[...null!==(_cleanupEffectsByStor2=cleanupEffectsByStore.get(store))&&void 0!==_cleanupEffectsByStor2?_cleanupEffectsByStor2:[],release])};for(const effect of effects)try{const cleanup=effect({node:node,storeID:store.storeID,parentStoreID_UNSTABLE:store.parentStoreID,trigger:trigger,setSelf:setSelf(effect),resetSelf:resetSelf(effect),onSet:onSet(effect),getPromise:getPromise,getLoadable:getLoadable,getInfo_UNSTABLE:getInfo_UNSTABLE});var _cleanupEffectsByStor3;if(null!=cleanup)cleanupEffectsByStore.set(store,[...null!==(_cleanupEffectsByStor3=cleanupEffectsByStore.get(store))&&void 0!==_cleanupEffectsByStor3?_cleanupEffectsByStor3:[],cleanup])}catch(error){initValue=error,isInitError=!0}if(isDuringInit=!1,!(initValue instanceof DefaultValue$2)){var _store$getState$nextT5;const initLoadable=isInitError?loadableWithError$2(initValue):Recoil_isPromise(initValue)?loadableWithPromise$2(function wrapPendingPromise(store,promise){const wrappedPromise=promise.then((value=>{var _store$getState$nextT,_state$atomValues$get;return(null===(_state$atomValues$get=(null!==(_store$getState$nextT=store.getState().nextTree)&&void 0!==_store$getState$nextT?_store$getState$nextT:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get?void 0:_state$atomValues$get.contents)===wrappedPromise&&setRecoilValue$4(store,node,value),value})).catch((error=>{var _store$getState$nextT2,_state$atomValues$get2;throw(null===(_state$atomValues$get2=(null!==(_store$getState$nextT2=store.getState().nextTree)&&void 0!==_store$getState$nextT2?_store$getState$nextT2:store.getState().currentTree).atomValues.get(key))||void 0===_state$atomValues$get2?void 0:_state$atomValues$get2.contents)===wrappedPromise&&setRecoilValueLoadable$2(store,node,loadableWithError$2(error)),error}));return wrappedPromise}(store,initValue)):loadableWithValue$3(unwrap(initValue));initLoadable.contents,initState.atomValues.set(key,initLoadable),null===(_store$getState$nextT5=store.getState().nextTree)||void 0===_store$getState$nextT5||_store$getState$nextT5.atomValues.set(key,initLoadable)}}return()=>{var _cleanupEffectsByStor;liveStoresCount--,null===(_cleanupEffectsByStor=cleanupEffectsByStore.get(store))||void 0===_cleanupEffectsByStor||_cleanupEffectsByStor.forEach((cleanup=>cleanup())),cleanupEffectsByStore.delete(store)}},invalidate:function invalidateAtom(){cachedAnswerForUnvalidatedValue=void 0},shouldDeleteConfigOnRelease:function shouldDeleteConfigOnReleaseAtom(){return void 0!==getConfigDeletionHandler$2(key)&&liveStoresCount<=0},dangerouslyAllowMutability:options.dangerouslyAllowMutability,persistence_UNSTABLE:options.persistence_UNSTABLE?{type:options.persistence_UNSTABLE.type,backButton:options.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:retainedBy});return node}function atom(options){const{...restOptions}=options,optionsDefault="default"in options?options.default:new Promise((()=>{}));return isRecoilValue$4(optionsDefault)?function atomWithFallback(options){const base=atom({...options,default:DEFAULT_VALUE$7,persistence_UNSTABLE:void 0===options.persistence_UNSTABLE?void 0:{...options.persistence_UNSTABLE,validator:storedValue=>storedValue instanceof DefaultValue$2?storedValue:Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue,DEFAULT_VALUE$7)},effects:options.effects,effects_UNSTABLE:options.effects_UNSTABLE}),sel=Recoil_selector({key:`${options.key}__withFallback`,get:({get:get})=>{const baseValue=get(base);return baseValue instanceof DefaultValue$2?options.default:baseValue},set:({set:set},newValue)=>set(base,newValue),cachePolicy_UNSTABLE:{eviction:"most-recent"},dangerouslyAllowMutability:options.dangerouslyAllowMutability});return setConfigDeletionHandler$1(sel.key,getConfigDeletionHandler$2(options.key)),sel}({...restOptions,default:optionsDefault}):baseAtom({...restOptions,default:optionsDefault})}atom.value=value=>new WrappedValue$2(value);var Recoil_atom=atom;var Recoil_MapCache_1=class MapCache{constructor(options){var _options$mapKey;_defineProperty(this,"_map",void 0),_defineProperty(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(_options$mapKey=null==options?void 0:options.mapKey)&&void 0!==_options$mapKey?_options$mapKey:v=>v}size(){return this._map.size}has(key){return this._map.has(this._keyMapper(key))}get(key){return this._map.get(this._keyMapper(key))}set(key,val){this._map.set(this._keyMapper(key),val)}delete(key){this._map.delete(this._keyMapper(key))}clear(){this._map.clear()}},Recoil_MapCache$1=Object.freeze({__proto__:null,MapCache:Recoil_MapCache_1});const{LRUCache:LRUCache$2}=Recoil_LRUCache$1,{MapCache:MapCache$1}=Recoil_MapCache$1,defaultPolicy$1={equality:"reference",eviction:"none",maxSize:1/0};var Recoil_cacheFromPolicy=function cacheFromPolicy({equality:equality=defaultPolicy$1.equality,eviction:eviction=defaultPolicy$1.eviction,maxSize:maxSize=defaultPolicy$1.maxSize}=defaultPolicy$1){const valueMapper=function getValueMapper$1(equality){switch(equality){case"reference":return val=>val;case"value":return val=>Recoil_stableStringify(val)}throw Recoil_err(`Unrecognized equality policy ${equality}`)}(equality);return function getCache(eviction,maxSize,mapKey){switch(eviction){case"keep-all":return new MapCache$1({mapKey:mapKey});case"lru":return new LRUCache$2({mapKey:mapKey,maxSize:Recoil_nullthrows(maxSize)});case"most-recent":return new LRUCache$2({mapKey:mapKey,maxSize:1})}throw Recoil_err(`Unrecognized eviction policy ${eviction}`)}(eviction,maxSize,valueMapper)};const{setConfigDeletionHandler:setConfigDeletionHandler$2}=Recoil_Node;var Recoil_atomFamily=function atomFamily(options){var _options$cachePolicyF,_options$cachePolicyF2;const atomCache=Recoil_cacheFromPolicy({equality:null!==(_options$cachePolicyF=null===(_options$cachePolicyF2=options.cachePolicyForParams_UNSTABLE)||void 0===_options$cachePolicyF2?void 0:_options$cachePolicyF2.equality)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:"value",eviction:"keep-all"});return params=>{var _stableStringify,_options$effects;const cachedAtom=atomCache.get(params);if(null!=cachedAtom)return cachedAtom;const{cachePolicyForParams_UNSTABLE:cachePolicyForParams_UNSTABLE,...atomOptions}=options,optionsDefault="default"in options?options.default:new Promise((()=>{})),newAtom=Recoil_atom({...atomOptions,key:`${options.key}__${null!==(_stableStringify=Recoil_stableStringify(params))&&void 0!==_stableStringify?_stableStringify:"void"}`,default:"function"==typeof optionsDefault?optionsDefault(params):optionsDefault,retainedBy_UNSTABLE:"function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE,effects:"function"==typeof options.effects?options.effects(params):"function"==typeof options.effects_UNSTABLE?options.effects_UNSTABLE(params):null!==(_options$effects=options.effects)&&void 0!==_options$effects?_options$effects:options.effects_UNSTABLE});return atomCache.set(params,newAtom),setConfigDeletionHandler$2(newAtom.key,(()=>{atomCache.delete(params)})),newAtom}};const{setConfigDeletionHandler:setConfigDeletionHandler$3}=Recoil_Node;let nextIndex=0;var Recoil_selectorFamily=function selectorFamily(options){var _options$cachePolicyF,_options$cachePolicyF2;const selectorCache=Recoil_cacheFromPolicy({equality:null!==(_options$cachePolicyF=null===(_options$cachePolicyF2=options.cachePolicyForParams_UNSTABLE)||void 0===_options$cachePolicyF2?void 0:_options$cachePolicyF2.equality)&&void 0!==_options$cachePolicyF?_options$cachePolicyF:"value",eviction:"keep-all"});return params=>{var _stableStringify;let cachedSelector;try{cachedSelector=selectorCache.get(params)}catch(error){throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`)}if(null!=cachedSelector)return cachedSelector;const myKey=`${options.key}__selectorFamily/${null!==(_stableStringify=Recoil_stableStringify(params,{allowFunctions:!0}))&&void 0!==_stableStringify?_stableStringify:"void"}/${nextIndex++}`,myGet=callbacks=>options.get(params)(callbacks),myCachePolicy=options.cachePolicy_UNSTABLE,retainedBy="function"==typeof options.retainedBy_UNSTABLE?options.retainedBy_UNSTABLE(params):options.retainedBy_UNSTABLE;let newSelector;if(null!=options.set){const set=options.set;newSelector=Recoil_selector({key:myKey,get:myGet,set:(callbacks,newValue)=>set(params)(callbacks,newValue),cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy})}else newSelector=Recoil_selector({key:myKey,get:myGet,cachePolicy_UNSTABLE:myCachePolicy,dangerouslyAllowMutability:options.dangerouslyAllowMutability,retainedBy_UNSTABLE:retainedBy});return selectorCache.set(params,newSelector),setConfigDeletionHandler$3(newSelector.key,(()=>{selectorCache.delete(params)})),newSelector}};const constantSelector=Recoil_selectorFamily({key:"__constant",get:constant=>()=>constant,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_constSelector=function constSelector(constant){return constantSelector(constant)};const throwingSelector=Recoil_selectorFamily({key:"__error",get:message=>()=>{throw Recoil_err(message)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var Recoil_errorSelector=function errorSelector(message){return throwingSelector(message)};var Recoil_readOnlySelector=function readOnlySelector(atom){return atom};const{loadableWithError:loadableWithError$3,loadableWithPromise:loadableWithPromise$3,loadableWithValue:loadableWithValue$4}=Recoil_Loadable$1;function concurrentRequests(getRecoilValue,deps){const results=Array(deps.length).fill(void 0),exceptions=Array(deps.length).fill(void 0);for(const[i,dep]of deps.entries())try{results[i]=getRecoilValue(dep)}catch(e){exceptions[i]=e}return[results,exceptions]}function isError(exp){return null!=exp&&!Recoil_isPromise(exp)}function unwrapDependencies(dependencies){return Array.isArray(dependencies)?dependencies:Object.getOwnPropertyNames(dependencies).map((key=>dependencies[key]))}function wrapResults(dependencies,results){return Array.isArray(dependencies)?results:Object.getOwnPropertyNames(dependencies).reduce(((out,key,idx)=>({...out,[key]:results[idx]})),{})}function wrapLoadables(dependencies,results,exceptions){return wrapResults(dependencies,exceptions.map(((exception,idx)=>null==exception?loadableWithValue$4(results[idx]):Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception))))}var Recoil_WaitFor={waitForNone:Recoil_selectorFamily({key:"__waitForNone",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return wrapLoadables(dependencies,results,exceptions)},dangerouslyAllowMutability:!0}),waitForAny:Recoil_selectorFamily({key:"__waitForAny",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.some((exp=>!Recoil_isPromise(exp)))?wrapLoadables(dependencies,results,exceptions):new Promise((resolve=>{for(const[i,exp]of exceptions.entries())Recoil_isPromise(exp)&&exp.then((result=>{results[i]=result,exceptions[i]=void 0,resolve(wrapLoadables(dependencies,results,exceptions))})).catch((error=>{exceptions[i]=error,resolve(wrapLoadables(dependencies,results,exceptions))}))}))},dangerouslyAllowMutability:!0}),waitForAll:Recoil_selectorFamily({key:"__waitForAll",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);if(exceptions.every((exp=>null==exp)))return wrapResults(dependencies,results);const error=exceptions.find(isError);if(null!=error)throw error;return Promise.all(exceptions).then((exceptionResults=>wrapResults(dependencies,function combineAsyncResultsWithSyncResults(syncResults,asyncResults){return asyncResults.map(((result,idx)=>void 0===result?syncResults[idx]:result))}(results,exceptionResults))))},dangerouslyAllowMutability:!0}),waitForAllSettled:Recoil_selectorFamily({key:"__waitForAllSettled",get:dependencies=>({get:get})=>{const deps=unwrapDependencies(dependencies),[results,exceptions]=concurrentRequests(get,deps);return exceptions.every((exp=>!Recoil_isPromise(exp)))?wrapLoadables(dependencies,results,exceptions):Promise.all(exceptions.map(((exp,i)=>Recoil_isPromise(exp)?exp.then((result=>{results[i]=result,exceptions[i]=void 0})).catch((error=>{results[i]=void 0,exceptions[i]=error})):null))).then((()=>wrapLoadables(dependencies,results,exceptions)))},dangerouslyAllowMutability:!0}),noWait:Recoil_selectorFamily({key:"__noWait",get:dependency=>({get:get})=>{try{return Recoil_selector.value(loadableWithValue$4(get(dependency)))}catch(exception){return Recoil_selector.value(Recoil_isPromise(exception)?loadableWithPromise$3(exception):loadableWithError$3(exception))}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:RecoilLoadable}=Recoil_Loadable$1,{DefaultValue:DefaultValue$3}=Recoil_Node,{RecoilRoot:RecoilRoot$2,useRecoilStoreID:useRecoilStoreID$1}=Recoil_RecoilRoot,{isRecoilValue:isRecoilValue$5}=Recoil_RecoilValue$1,{retentionZone:retentionZone$1}=Recoil_RetentionZone,{freshSnapshot:freshSnapshot$2}=Recoil_Snapshot$1,{useRecoilState:useRecoilState$1,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useRecoilValue:useRecoilValue$1,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,useResetRecoilState:useResetRecoilState$1,useSetRecoilState:useSetRecoilState$1}=Recoil_Hooks,{useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver:useRecoilTransactionObserver$1}=Recoil_SnapshotHooks,{useRecoilCallback:useRecoilCallback$1}=Recoil_useRecoilCallback,{noWait:noWait$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,waitForAny:waitForAny$1,waitForNone:waitForNone$1}=Recoil_WaitFor;var Recoil_index={DefaultValue:DefaultValue$3,isRecoilValue:isRecoilValue$5,RecoilLoadable:RecoilLoadable,RecoilEnv:Recoil_RecoilEnv,RecoilRoot:RecoilRoot$2,useRecoilStoreID:useRecoilStoreID$1,useRecoilBridgeAcrossReactRoots_UNSTABLE:Recoil_useRecoilBridgeAcrossReactRoots,atom:Recoil_atom,selector:Recoil_selector,atomFamily:Recoil_atomFamily,selectorFamily:Recoil_selectorFamily,constSelector:Recoil_constSelector,errorSelector:Recoil_errorSelector,readOnlySelector:Recoil_readOnlySelector,noWait:noWait$1,waitForNone:waitForNone$1,waitForAny:waitForAny$1,waitForAll:waitForAll$1,waitForAllSettled:waitForAllSettled$1,useRecoilValue:useRecoilValue$1,useRecoilValueLoadable:useRecoilValueLoadable$1,useRecoilState:useRecoilState$1,useRecoilStateLoadable:useRecoilStateLoadable$1,useSetRecoilState:useSetRecoilState$1,useResetRecoilState:useResetRecoilState$1,useGetRecoilValueInfo_UNSTABLE:Recoil_useGetRecoilValueInfo,useRecoilRefresher_UNSTABLE:Recoil_useRecoilRefresher,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,useRecoilCallback:useRecoilCallback$1,useRecoilTransaction_UNSTABLE:Recoil_useRecoilTransaction,useGotoRecoilSnapshot:useGotoRecoilSnapshot$1,useRecoilSnapshot:useRecoilSnapshot$1,useRecoilTransactionObserver_UNSTABLE:useRecoilTransactionObserver$1,snapshot_UNSTABLE:freshSnapshot$2,useRetain:Recoil_useRetain,retentionZone:retentionZone$1},Recoil_index_5=Recoil_index.RecoilRoot,Recoil_index_8=Recoil_index.atom,Recoil_index_9=Recoil_index.selector,Recoil_index_11=Recoil_index.selectorFamily,Recoil_index_20=Recoil_index.useRecoilValue,Recoil_index_24=Recoil_index.useSetRecoilState}}]);